<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma"        content="no-cache">
  <meta http-equiv="Expires"       content="0">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">

  <title>Animatey</title>
  <style>

    body {
      font-family: system-ui, sans-serif;
      font-size: 15px;
      line-height: 1.5;
      color: #333;
            margin: 0;
      display: flex;
      height: 100vh;
    }

    h1, h2, h3 {
      font-weight: 600;
      letter-spacing: -0.02em;
      color: #222;
    }

    .pro-header span {
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #555;
    }

    #leftSidebar, #rightSidebar {
      min-width: 350px;
      max-width: 450px;
      padding: 10px;
      box-sizing: border-box;
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      overflow-y: auto;
      box-shadow: 0 0 6px rgba(0,0,0,0.08);
    }

    #rightSidebar {
      border-right: none;
      border-left: 1px solid #ccc;
    }

    #mainContent {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 0 6px rgba(0,0,0,0.08);
    }

    canvas {
      background: #f0f0f0;
      margin-top: 10px;
      cursor: pointer;
      isolation: isolate;
      border: 1px solid #ccc;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }

    #bigPlay {
      width: 100%;
      display: flex;
      justify-content: center; /* horizontal */
    }

    #shapeList, #objectList, #canvasList {
      margin-top: 10px;
      max-height: 100%;
      overflow-y: auto;
      border: 1px solid #aaa;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    #timeline {
      overflow-y: auto;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* IE/Edge */
      scroll-behavior: smooth;
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-top: 10px;
      max-height: 100%;
      border: 1px solid #aaa;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
    }

    .aim-btn, .lock-btn {
      margin: unset;
      background: none;
      border: none;
    }
    
    #playAnimation.playing,
    #loopAnimation.playing,
    #bounceAnimation.playing {
      background-color: #2ecc71;
      color: white;
      border: none;
    }

    input[type="color"] {
      border: none;
      padding: 0;
      margin-right: 6px;
      width: 32px;
      height: 24px;
      background: none;
      isolation: isolate;
    }
    
    /* Hint in the corner */
    #shortcut-hint {
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 0.9rem;
      z-index: 1000;
    }
    #shortcut-hint kbd {
      background: #444;
      color: #fff;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 0.9em;
      font-family: monospace;
    }

    /* Modal overlay */
    #shortcut-modal {
      display: none; /* hidden by default */
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.5);
      z-index: 2000;
    }

    /* Modal content box */
    .modal-content {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid #ddd;
    }
    .modal-header h2 {
      margin: 0;
      font-size: 1.25rem;
    }
    #close-modal {
      background: none;
      border: none;
      font-size: 1.5rem;
      line-height: 1;
      cursor: pointer;
    }

    .modal-body {
      padding: 16px;
    }
    .modal-body ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .modal-body li {
      margin: 8px 0;
      font-size: 1rem;
    }
    .modal-body kbd {
      background: #f7f7f7;
      border: 1px solid #ccc;
      border-radius: 3px;
      padding: 2px 4px;
      font-family: monospace;
      font-size: 0.9em;
      box-shadow: inset 0 -1px 0 #bbb;
    }

    /* Sidebar container */
    #sidebar {
      background: #f9f9f9;
      border-right: 1px solid #ccc;
      display: flex;
      flex-direction: column;
    }
    /* Tab headers */
    .tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
    }
    .tab {
      flex: 1;
      text-align: center;
      padding: 10px;
      cursor: pointer;
      background: #eee;
      border-right: 1px solid #ccc;
      user-select: none;
    }
    .tab:last-child { border-right: none; }
    .tab.active {
      background: #fff;
      font-weight: bold;
    }
    /* Tab content areas */
    .tab-content {
      flex: 1;
      padding: 10px;
      display: none;
      overflow-y: auto;
    }
    .tab-content.active { display: block; }

    #sidebar label { display: block; margin: 8px 0; }
    #sidebar input[type="text"], #sidebar input[type="number"], #sidebar select {
      padding: 4px;
      box-sizing: border-box;
    }
   /* Pixasearch */
    #searchBox {
      width: 250px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #results {
      margin-top: 15px;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 10px;
    }
    .result-card {
      position: relative;
      overflow: hidden;
    }
    .result-card img {
      width: 100%;
      height: auto;
      border-radius: 4px;
      cursor: pointer;
      transition: transform 0.2s;
      display: block;
    }
    .result-card img:hover {
      transform: scale(1.1);
    }
    .add-btn {
      position: absolute;
      top: 6px;
      right: 6px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 22px;
      height: 22px;
      font-size: 14px;
      line-height: 22px;
      text-align: center;
      cursor: pointer;
      padding: 0;
    }
    #pagination {
      margin-top: 15px;
      display: none; /* hidden by default */
      justify-content: center;
      gap: 20px;
      align-items: center;
    }
    .chevron {
      cursor: pointer;
      font-size: 24px;
      user-select: none;
      color: #333;
    }
    .chevron.disabled {
      color: #aaa;
      cursor: default;
    }
    /* lightweight card + actions bar */
    .result-card {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .result-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .result-actions button {
      padding: 4px 6px;
      font-size: 12px;
      cursor: pointer;
    }
    .result-actions a {
      font-size: 12px;
      color: #0366d6;
      text-decoration: none;
    }
    .result-actions a:hover {
      text-decoration: underline;
    }

     /* Containers */
    #shapeList.shape-list--pro,
    #objectList.object-list--pro,
    #canvasList.object-list--pro,
    #filesList.object-list--pro,
    #timeline.kf-list--pro {
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 8px;
      padding: 8px;
      box-shadow: 0 1px 0 rgba(0,0,0,.03);
    }

    /* Headers (shared) */
    .pro-header {
      position: sticky; top: -8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 8px 10px;
      font-size: 0.95rem;
      margin-bottom: 8px;
      display:flex; align-items:center; gap:10px;
      z-index: 1;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #555;
      background: linear-gradient(#fafafa, #f1f1f1);


    }

    /* Rows: share all “shape-row” rules with “kf-row” */
    .shape-row, .kf-row {
      display:grid;
      grid-template-columns: 22px 1fr auto;
      grid-template-areas:
        "drag name actions"
        ".    meta meta";
      gap:6px 10px;
      padding:8px;
      border: 1px solid #eee;
      border-radius:8px;
      margin-bottom:6px;
      background:#fff;
      align-items:center;
    }

    .drag-over {
      border: 2px dashed #007bff;
    }
    .shape-row:hover, .kf-row:hover { background:#f9fbff; border-color:#dbe7ff; }
    .shape-row.selected, .kf-row.selected { outline: 2px solid #2684ff33; background:#eef5ff; }
    .shape-row.drag-over, .kf-row.drag-over { border-style: dashed; border-color:#2684ff; background:#f5f9ff; }

    .shape-row .drag, .kf-row .drag { grid-area: drag; color:#777; cursor: grab; user-select:none; font-size:16px; text-align:center; }
    .shape-row .drag:active, .kf-row .drag:active { cursor: grabbing; }

    .shape-row .name, .kf-row .name { grid-area: name; display:flex; align-items:center; gap:8px; min-width:0; }
    .shape-row .swatch, .kf-row .swatch { width:18px; height:18px; border-radius:4px; border:1px solid #0001; box-shadow: inset 0 0 0 1px #0000000f; }
    .shape-row .title, .kf-row .title { font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; cursor:pointer; }

    .shape-row .meta, .kf-row .meta { grid-area: meta; display:flex; flex-wrap:wrap; gap:8px; padding-left:22px; font-size:12px; color:#333; }
    .shape-row .mini, .kf-row .mini { display:inline-flex; align-items:center; gap:4px; }
    .shape-row .mini input[type="number"], .kf-row .mini input[type="number"] { width:56px; padding:2px 4px; font-size:12px; }
    .shape-row .mini .lock, .kf-row .mini .lock { background:none; border:1px solid #ccc; border-radius:6px; padding:2px 6px; cursor:pointer; }
    .shape-row .mini .icon, .kf-row .mini .icon { opacity:.75; }

    .shape-row .actions, .kf-row .actions { grid-area: actions; display:flex; align-items:center; gap:6px; }
    .shape-row .actions .btn, .kf-row .actions .btn,
    .kf-row .actions button { border:1px solid #ccc; background:#fff; padding:2px 6px; border-radius:6px; cursor:pointer; }

    .kf-row.playing {
      background: linear-gradient(90deg, #28a745 0%, #34ce57 100%);
      color: #fff;
      border-left: 4px solid #1e7e34;
      box-shadow: 0 0 6px rgba(40,167,69,0.4);
      font-weight: 600;
      transform: translateX(2px);
      transition: all 0.2s ease;
    }

    .kf-row.playing .title {
      color: #fff;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .group-control {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 6px;
      width: -moz-available;          /* WebKit-based browsers will ignore this. */
      width: -webkit-fill-available;  /* Mozilla-based browsers will ignore this. */
      width: stretch;
    }
    .group-control input[type="number"] {
      width: 68px;
      padding: 2px 4px;
    }
    #fpsButtons button {
      padding: 2px 6px;
      margin-left: 2px;
      font-size: 0.85em;
      cursor: pointer;
    }
    #fpsButtons button.active {
      font-weight: bold;
      cursor: default;
    }

    /* PLAY TOGGLE BUTTON */
     .bigPlayBtn{
      width:150px;         /* wider, like a spacebar */
      height:50px;         /* flatter height */
      border-radius:12px;  /* soft rectangle corners */
      border:none;
      cursor:pointer;
      display:grid;
      place-items:center;
      transition: background .25s ease, transform .18s ease, filter .18s ease;
    }
    
    /* Prevent focus visuals */ .bigPlayBtn:focus{ outline:none; }

    .bigPlayBtn:hover{ filter:brightness(1.08); }
    .bigPlayBtn:active{ transform:scale(.95); }
    .bigPlayBtn.fake-active { transform: scale(.95); }

    .icon{
      width:25%;           /* scaled down to fit new shape */
      aspect-ratio:1;
      position:relative;
    }
    .icon svg{
      position:absolute;
      inset:0;
      width:100%; height:100%;
      fill:#fff;
      transition:opacity .2s ease, transform .2s ease;
    }
    .icon .stop{ opacity:0; transform:scale(.8); }
    .icon .play{ opacity:1; transform:scale(1); }

    /* State styles with muted colors */
    .bigPlayBtn[data-state="play"]{
      background:#6fcf97; /* soft green */
    }
    .bigPlayBtn[data-state="stop"]{
      background:#eb746c; /* soft red */
    }

    .bigPlayBtn[data-state="stop"] .icon .play{ opacity:0; transform:scale(.8); }
    .bigPlayBtn[data-state="stop"] .icon .stop{ opacity:1; transform:scale(1); }

    .btn:disabled, .btn[disabled] {
      border: 1px solid #00000000 !important;
      background: #00000000 !important;
      opacity: 0.3 !important;
      cursor: default !important;
      filter: grayscale(100%) !important;
      color: #888;
    }
    button {
      margin-left: 5px;
      background: #f5f5f5;
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
    }
    button:hover {
      background: #e9e9e9;
    }
    button:active {
      transform: scale(0.97);
    }
    #shapeList::-webkit-scrollbar,
    #timeline::-webkit-scrollbar {
      width: 8px;
    }
    #shapeList::-webkit-scrollbar-thumb,
    #timeline::-webkit-scrollbar-thumb {
      background: #bbb;
      border-radius: 4px;
    }
    #shapeList::-webkit-scrollbar-thumb:hover,
    #timeline::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    .tab, .tab-content, .pro-header, .group-control {
      transition: background 0.25s, color 0.25s, box-shadow 0.25s;
    }

    #res-widget {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    #res-widget select {
      padding: 4px 6px;
      font-size: 0.9em;
    }

    .res-dimensions {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap; /* keep everything on one line */
    }


  /* Split button (consolidated) */
.split {
  display: inline-flex;
  position: relative;      /* menu anchors to this */
  align-items: stretch;
}
.split .btn {
  border-radius: 0;
  margin-left: 0;
}
.split .btn-main { border-radius: 6px 0 0 6px; }
.split .dropdown { position: static; display: flex; }
.split .btn-caret {
  border-left: none;
  border-radius: 0 6px 6px 0;
  display: grid;
  place-items: center;
}
.split .caret {
  width: 0; height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 7px solid #666;
}
.split .dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 220px;
  background: #fff;
  border: 1px solid #ccc;
  display: none;                 /* base hidden state */
  flex-direction: column;
  z-index: 1000;
  box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  border-radius: 6px;
  margin-top: 4px;
  overflow: hidden;
}
.split .dropdown.open .dropdown-menu { display: flex; }  /* single source of truth */

.split .dropdown-menu button {
  background: #fff;
  color: #222;
  padding: 10px 12px;
  border: none;
  text-align: left;
  cursor: pointer;
}
.split .dropdown-menu button + button { border-top: 1px solid #eee; }

/* ─────────────────────────────────────────────────────────────
   SPLIT DELETE — FINAL: clean corners + slim caret + working menu
   (scoped to the shapes list actions only)
   ──────────────────────────────────────────────────────────── */
.shape-row .actions .split{
  display:inline-flex;
  position:relative;
  align-items:stretch;

  /* single rounded outline around both halves */
  border:1px solid #ccc !important;
  border-radius:6px !important;
  background:#fff;
  background-clip: padding-box;

  /* allow dropdown to escape the button (harmless if removed) */
  overflow:visible;
}

/* fuse halves (kill any inner gaps/borders/radii that fight the outline) */
.shape-row .actions .split .btn,
.shape-row .actions .split button{
  margin:0 !important;
  border:0 !important;
}
/* keep global press animation elsewhere, not inside split */
.shape-row .actions .split button:active{ transform:none !important; }

/* main half: no old inset divider, draw a shorter divider so corners stay intact */
.shape-row .actions .split .btn-main{
  position:relative;
  box-shadow:none !important;      /* neutralize any earlier full-height divider */
}
.shape-row .actions .split .btn-main::after{
  content:"";
  position:absolute;
  right:0;
  top:3px;                         /* inset so it doesn't collide with rounded corners */
  bottom:3px;
  width:1px;
  background:#ccc;
}

/* ultra-slim caret half (almost hidden) */
.shape-row .actions .split .btn-caret{
  width:14px;
  min-width:14px;
  padding:0;
}
.shape-row .actions .split .caret{
  width:0; height:0;
  border-left:5px solid transparent;
  border-right:5px solid transparent;
  border-top:6px solid #666;
  pointer-events:none;             /* clicks go to the button */
}

/* dropdown: opens inward from the right and stays clickable */
.shape-row .actions .split .dropdown-menu{
  position:absolute;
  top:calc(100% + 6px);
  right:0;                         /* anchor to the right edge */
  left:auto;
  min-width:260px;
  background:#fff;
  border:1px solid #ccc;
  border-radius:10px;
  box-shadow:0 14px 40px rgba(0,0,0,0.12);
  flex-direction:column;
  z-index:3000;
  overflow:hidden;
}

.shape-row .actions .split .dropdown-menu button{
  background:#fff;
  color:#222;
  padding:10px 14px;
  border:none;
  text-align:left;
  cursor:pointer;
  margin:0;
  font-size:14px;
}
.shape-row .actions .split .dropdown-menu button + button{
  border-top:1px solid #eee;
}


/* Subtle grey hover for dropdown items (additive, no overrides removed) */
.split .dropdown-menu button{
  transition: background-color .12s ease !important; /* smoothen it a bit */
}

.split .dropdown-menu button:hover{
  background: #f3f4f6 !important; /* subtle grey hover */
}

/* Optional: a slightly different tone on keyboard focus for accessibility */
.split .dropdown-menu button:focus-visible{
  background: #eef1f4 !important;
  outline: 2px solid #0a7 !important;   /* matches your existing focus style */
  outline-offset: -2px !important;       /* keeps outline inside the popover */
}

</style>


</head>
<body>
  <div id="leftSidebar">

    <div id="canvasList" class="object-list--pro">
        <div class="pro-header"><span>Settings</span></div>


        
        <div id="fps-widget" class="group-control">
          <label for="fpsInput">FPS:</label>
        <input type="number" id="fpsInput" min="1" max="240" step="1" value="60">
        <div id="fpsButtons">
          <button type="button" data-fps="1">1</button>
          <button type="button" data-fps="12">12</button>
          <button type="button" data-fps="24">24</button>
          <button type="button" data-fps="30">30</button>
          <button type="button" data-fps="60">60</button>
          <button type="button" data-fps="120">120</button>
        </div>
      </div>

      <p>

<div id="res-widget" class="group-control">
  <label for="resolutionPreset">Resolution:</label>
  
  <select id="resolutionPreset">
    <option value="">Custom</option>
    <option value="1280x720">HD 1280×720 (16:9)</option>
    <option value="1920x1080">Full HD 1920×1080 (16:9)</option>
    <option value="2560x1440">QHD 2560×1440 (16:9)</option>
    <option value="3840x2160">4K 3840×2160 (16:9)</option>
    <option value="1024x768">1024×768 (4:3)</option>
    <option value="720x720">720×720 (1:1 Square)</option>
    <option value="1080x1350">1080×1350 (Instagram Portrait)</option>
  </select>

  <div class="res-dimensions">
    <label for="canvasWidth">w:</label>
    <input type="number" id="canvasWidth" min="1" max="8192" step="1" value="800">
    <label for="canvasHeight">h:</label>
    <input type="number" id="canvasHeight" min="1" max="8192" step="1" value="600">
  </div>
</div>


<script>
  const canvasWidthInput = document.getElementById('canvasWidth');
  const canvasHeightInput = document.getElementById('canvasHeight');
  const resolutionPreset = document.getElementById('resolutionPreset');

  function updateCanvasSize(w, h) {
    if (!w || !h) return;
    // update animation object
    animation.canvas.width = w;
    animation.canvas.height = h;

    // update base values for mouse normalization
    _baseCssWidth = w;
    _baseCssHeight = h;

    // update CSS size and underlying resolution (respect HiDPI)
    const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    canvas.style.width  = w + 'px';
    canvas.style.height = h + 'px';
    canvas.width  = w * ratio;
    canvas.height = h * ratio;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

    // redraw
    drawAllShapes();
  }

  // manual input changes
  canvasWidthInput.addEventListener('change', () => {
    const w = parseInt(canvasWidthInput.value, 10);
    const h = parseInt(canvasHeightInput.value, 10);
    if (w > 0 && h > 0) updateCanvasSize(w, h);
  });

  canvasHeightInput.addEventListener('change', () => {
    const w = parseInt(canvasWidthInput.value, 10);
    const h = parseInt(canvasHeightInput.value, 10);
    if (w > 0 && h > 0) updateCanvasSize(w, h);
  });

  // preset dropdown
  resolutionPreset.addEventListener('change', () => {
    const val = resolutionPreset.value;
    if (!val) return;
    const [w, h] = val.split('x').map(n => parseInt(n, 10));
    if (w && h) {
      canvasWidthInput.value = w;
      canvasHeightInput.value = h;
      updateCanvasSize(w, h);
    }
  });
</script>
      
      <p>
      
      <div class="group-control">
        <label for="bgColorInput">Background:</label>
        <input type="color" id="bgColorInput" value="#f0f0f0" title="Set background color">
          <button id="bgInputBtn" onmousedown="event.preventDefault();">Load Image</button>
          <input type="file" id="bgInput" style="display:none;" accept="image/*">
          <button id="clearBackground" onmousedown="event.preventDefault();">Clear</button>
      </div>    
    </div>

    <div id="objectList" class="object-list--pro">
        <div class="pro-header"><span>Add Object</span></div>
        
        <div id="sidebar">
            <div class="tabs">
              <div class="tab active" data-target="textTab">Text 🔡</div>
              <div class="tab" data-target="imageTab">Image 🖼️</div>
              <div class="tab" data-target="shapesTab">Shape ⬜</div>
              <div class="tab" data-target="drawTab">Draw 🎨</div>
            </div>

          <!-- Text section -->
          <div id="textTab" class="tab-content active">
            <label>
              Enter Text:
              <input type="text" id="textContent" placeholder=""><button id="emojiButton">😀</button>
            </label>
  
          <button id="addTextBtn">Add Text</button>
        </div>

        <!-- Images section -->
        <div id="imageTab" class="tab-content">
          
          <input type="file" id="imageInput" style="display:none;" accept="image/*">
            <label>Select Image:
          <button id="addImageBtn">Add Image</button></label>

            Image Search
          <input type="text" id="searchBox" placeholder="Search images..." />

          <div id="pagination">
            <span id="prevBtn" class="chevron">«</span>
            <span id="pageInfo">Page 1</span>
            <span id="nextBtn" class="chevron">»</span>
          </div>
          <div id="results"></div>

        </div>

        <!-- Shapes section -->
        <div id="shapesTab" class="tab-content">
            <label><input type="radio" name="shapeType" value="rectangle" checked> Rectangle</label>
            <label><input type="radio" name="shapeType" value="square"> Square</label>
            <label><input type="radio" name="shapeType" value="circle"> Circle</label>
            <label><input type="radio" name="shapeType" value="triangle"> Triangle</label>

            <button id="addShapeBtn">Add Shape</button>
        </div>

        <!-- Draw section -->
        <div id="drawTab" class="tab-content">
            <label><input type="checkbox" id="drawPencilChk" name="drawType" value="pencil"> Pencil ✏️</label>
        </div>

      </div>
    </div>

    <div id="shapeList"></div>

  </div>

  <div id="mainContent">
    <img id="logoImg" src="logo_beta.png" width="140">
    <div id="canvasViewport">
      <canvas id="canvas" width="800" height="600"></canvas>
      
    </div>
    <div id="controls">
        <div id="bigPlay">
          <button class="bigPlayBtn" id="newPlayBtn" data-state="play">
            <span class="icon" aria-hidden="true">
              <!-- Play -->
              <svg class="play" viewBox="0 0 100 100"><path d="M35 20 L80 50 L35 80 Z"/></svg>
              <!-- Stop -->
              <svg class="stop" viewBox="0 0 100 100"><rect x="30" y="30" width="40" height="40"/></svg>
            </span>
            <span id="playTimer" style="
              position:relative;
              bottom:4px;
              font-size:11px;
              color:#fff;
              opacity:0;
              pointer-events:none;
              font-family:monospace;">
            </span>
        </button>
        </div>

      <button id="loopAnimation" onmousedown="event.preventDefault();">↻ Loop</button>
      <button id="bounceAnimation" onmousedown="event.preventDefault();">↔ Bounce</button>
      <button id="fullscreenBtn" onmousedown="event.preventDefault();">⛶ Fullscreen</button>
      <button id="onionToggleBtn" onmousedown="event.preventDefault();">🧅 Onion Skin</button>
      <button id="motionPathToggleBtn" onmousedown="event.preventDefault();">🔵 Motion Paths</button>


        <!-- Hint to the user -->
      <div id="shortcut-hint">
        Press <kbd>?</kbd> to view keyboard shortcuts
      </div>
    </div>
    <div id="historyBarContainer" style="margin-top:6px; text-align:center;"></div>
  </div>

  <div id="rightSidebar">

    <div id="filesList" class="object-list--pro">
        <div class="pro-header"><span>Files:</span></div>

        <button id="importBtn" onmousedown="event.preventDefault();">Open Project</button>
        <input type="file" id="importFile" style="display:none;" accept=".json">

        <!-- Split Save Button -->
<div id="saveSplit" class="split" style="margin-left:0;">
  <button type="button" class="btn btn-main" id="exportBtn" onmousedown="event.preventDefault();" title="Save Project (without history)">
    Save Project
  </button>

  <div class="dropdown">
    <button type="button" class="btn btn-caret" aria-label="More save options">
      <span class="caret"></span>
    </button>
    <div class="dropdown-menu">
      <button type="button" onmousedown="document.getElementById('exportBtn').click();" title="Save project">
        Normal Save (default)
      </button>

      <button type="button" id="exportWithHistoryBtn" onmousedown="event.preventDefault();" title="Save project including undo/redo history">
        <b>Legendary Save</b> (includes undo/redo history) 🕰️
      </button>
    </div>
  </div>
</div>
        <button id="demoBtn">Load Demo Project</button><p>
        <button id="exportGifBtn" onmousedown="event.preventDefault();">Export .GIF</button>
        <progress id="gifProgress" value="0" max="1" style="width:100%; display:none;"></progress>


    </div>

    <p>

    <button id="cloneKeyframe">Clone Keyframe</button>
    <button id="addKeyframe">New Keyframe</button>
    <div id="timeline"></div>
</div>

<div id="mobile-blocker" aria-modal="true" role="dialog" aria-label="Mobile not supported"
     style="position: fixed; inset: 0; z-index: 10002 !important; display: none; align-items: center; justify-content: center; background: #111; color: #fff;">
  <div class="box" style="background: #465985; padding: 16px 20px; border-radius: 8px; width: 100%; text-align: center; line-height: 1.4;">
   <img src="logo_beta.png" width="150">
    <h2 style="margin:0 0 8px;">Not supported on mobile :(</h2>
    <p style="margin:0 0 8px;">Please open Animatey on a desktop or laptop.</p>
  </div>
</div>

<script>
(function(){
  function isMobileish(){
    const touch   = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
    const coarse  = window.matchMedia && matchMedia('(pointer: coarse)').matches;
    const noHover = window.matchMedia && matchMedia('(hover: none)').matches;
    const narrow  = Math.min(window.innerWidth, (screen && screen.width) || window.innerWidth) <= 820;
    const ua      = navigator.userAgent || '';
    const mobileUA= /Android|iPhone|iPad|iPod|Mobile|IEMobile|Windows Phone/i.test(ua);
    return (coarse && noHover) || (touch && (narrow || mobileUA));
  }

function showBlocker(){
  const el = document.getElementById('mobile-blocker');
  if (!el) return;
  el.style.display = 'flex';
  // ensure it's a direct child of <body>, then remove everything else
  if (el.parentNode !== document.body) document.body.appendChild(el);
  document.body.replaceChildren(el);
  // lock scrolling completely
  document.documentElement.style.overflow = 'hidden';
  document.documentElement.style.height = '100%';
  document.body.style.overflow = 'hidden';
  document.body.style.height = '100%';
}
  if (isMobileish()) showBlocker();

})();
</script>
<script>
  const API_KEY = "21438573-416fcdaef6b6d40e4e93ab6c6";
  const searchBox = document.getElementById("searchBox");
  const resultsDiv = document.getElementById("results");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const pageInfo = document.getElementById("pageInfo");

  let currentPage = 1;
  let currentQuery = "";
  const perPage = 12;
  let totalPages = 1;

  async function searchPixabay(query, page = 1) {
    if (!query) {
      resultsDiv.innerHTML = "";
      pageInfo.textContent = "Page 0";
      prevBtn.classList.add("disabled");
      nextBtn.classList.add("disabled");
      return;
    }

    const url = `https://pixabay.com/api/?key=${API_KEY}&q=${encodeURIComponent(query)}&image_type=photo&per_page=${perPage}&page=${page}`;
    try {
      document.body.style.cursor = 'progress';
      const response = await fetch(url);
      document.body.style.cursor = '';
      const data = await response.json();

      resultsDiv.innerHTML = "";
      if (data.hits && data.hits.length > 0) {
        document.getElementById("pagination").style.display = "flex";

        data.hits.forEach(img => {
          // Card container
          const card = document.createElement("div");
          card.className = "result-card";

          // Thumbnail
          const imageEl = document.createElement("img");
          imageEl.src = img.previewURL;
          imageEl.alt = img.tags;
          imageEl.title = img.tags;
          imageEl.onclick = () => window.open(img.largeImageURL || img.webformatURL, "_blank");

          // Corner ➕ button
          const addBtn = document.createElement("button");
          addBtn.className = "add-btn";
          addBtn.textContent = "+";
          addBtn.title = "Add to canvas";
          addBtn.onclick = (e) => {
            e.stopPropagation();
            const src = img.webformatURL || img.largeImageURL || img.previewURL;
            addImageShapeFromURL(src);
          };

          card.appendChild(imageEl);
          card.appendChild(addBtn);
          resultsDiv.appendChild(card);
        });

        totalPages = Math.ceil(data.totalHits / perPage);
        pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;

        prevBtn.classList.toggle("disabled", currentPage === 1);
        nextBtn.classList.toggle("disabled", currentPage >= totalPages);

      } else {
        document.getElementById("pagination").style.display = "none";

        resultsDiv.innerHTML = "<p>No results found.</p>";
        pageInfo.textContent = "Page 0";
        prevBtn.classList.add("disabled");
        nextBtn.classList.add("disabled");
      }
    } catch (err) {
      document.body.style.cursor = '';
      console.error("Pixabay fetch error:", err);
      resultsDiv.innerHTML = "<p>Error fetching images.</p>";
    }
  }

  searchBox.addEventListener("input", () => {
    currentQuery = searchBox.value.trim();
    currentPage = 1;
    searchPixabay(currentQuery, currentPage);
  });

  prevBtn.addEventListener("click", () => {
    if (currentPage > 1 && !prevBtn.classList.contains("disabled")) {
      currentPage--;
      searchPixabay(currentQuery, currentPage);
    }
  });

  nextBtn.addEventListener("click", () => {
    if (currentPage < totalPages && !nextBtn.classList.contains("disabled")) {
      currentPage++;
      searchPixabay(currentQuery, currentPage);
    }
  });

  function addImageShapeFromURL(src) {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const maxW = 200, maxH = 200;
      let w = img.naturalWidth, h = img.naturalHeight;
      const scale = Math.min(1, maxW / w, maxH / h);
      w = Math.max(1, Math.round(w * scale));
      h = Math.max(1, Math.round(h * scale));

      const s = {
        id: shapeIdCounter++,
        type: 'image',
        x: 100 + Math.random() * 400,
        y: 100 + Math.random() * 250,
        w, h,
        angle: 0,
        z: shapes.length,
        locked: true,
        mode: 0,
        src: src,
        _img: img
      };

      shapes.push(s);

      if (currentKeyframeIndex != null) {
        for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
          animation.keyframes[i].shapes.push(cloneShape(s));
        }
      }

      updateShapeList();
      drawAllShapes();
      commit('New Object (Img from URL)');
    };
    img.onerror = () => {
      alert("Failed to load image from Pixabay URL.");
    };
    img.src = src;
  }
</script>
<script>
  // Tab switching
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(tab.dataset.target).classList.add('active');

      if (tab.dataset.target !== 'drawTab') { exitFreehandMode();}

    });
  });

  document.getElementById("drawPencilChk").addEventListener("change", function() {
    if (this.checked) {
      enableFreehandMode();
    } else {
      exitFreehandMode();
    }
  });

  document.getElementById('addTextBtn').onclick = () => {
    //alert(`Add Text: "${document.getElementById('textContent').value}" size ${document.getElementById('fontSize').value}px`);
    addObject('text');
  };

  document.getElementById('addImageBtn').onclick = () => {
    addObject('image');
  };

  document.getElementById('addShapeBtn').onclick = () => {
      const type = document.querySelector('input[name="shapeType"]:checked').value;
      addObject(type);   
  };
</script>
<script src="tutorial.js"></script>
<script src="default_animation.js"></script>
<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  (function setupHiDPI(){
    const ratio = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const cssW = canvas.width, cssH = canvas.height;
    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width  = cssW * ratio;
    canvas.height = cssH * ratio;
    ctx.setTransform(ratio,0,0,ratio,0,0);
  })();

  // Mouse normalization for fullscreen
  // fixme: hardcoded canvas size
  let _baseCssWidth  = parseFloat(getComputedStyle(canvas).width)  || 800;
  let _baseCssHeight = parseFloat(getComputedStyle(canvas).height) || 600;

  function _mouseToCanvasSpace(e){
    //fixme: cache getBoundingClientRect() so its not called on all mousemove events etc
    const rect = canvas.getBoundingClientRect();
    //Convert from client pixels (fullscreen-scaled) to the canvas's original CSS pixel space
    return {
      x: (e.clientX - rect.left) * (_baseCssWidth  / rect.width),
      y: (e.clientY - rect.top)  * (_baseCssHeight / rect.height)
    };
  }

  const leftSidebar = document.getElementById('leftSidebar');
  const rightSidebar = document.getElementById('rightSidebar');

  const addShapeBtn = document.getElementById('addShapeBtn');
  const shapeListDiv = document.getElementById('shapeList');

  const addKeyframeBtn = document.getElementById('addKeyframe');
  const cloneKeyframeBtn = document.getElementById('cloneKeyframe');

  const newPlayBtn = document.getElementById('newPlayBtn');
  newPlayBtn.addEventListener('pointerdown', (e) => {
    newPlayBtn.setPointerCapture(e.pointerId);
  });
  const loopBtn = document.getElementById('loopAnimation');
  const bounceBtn = document.getElementById('bounceAnimation');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const bgColorInput = document.getElementById('bgColorInput');
  const bgInputBtn = document.getElementById('bgInputBtn');
  const bgInput       = document.getElementById('bgInput');
  const clearBgBtn    = document.getElementById('clearBackground');

  const demoBtn = document.getElementById('demoBtn');

  const exportBtn = document.getElementById('exportBtn');

      // Split "Save Project" dropdown logic
    const saveSplit = document.getElementById('saveSplit');
    const saveDropdown = saveSplit.querySelector('.dropdown');
    const saveCaret = saveSplit.querySelector('.btn-caret');
    const exportWithHistoryBtn = document.getElementById('exportWithHistoryBtn');

    // Toggle dropdown visibility
    saveCaret.addEventListener('click', (e) => {
      e.stopPropagation();
      saveDropdown.classList.toggle('open');
    });

    // Close if user clicks elsewhere
    window.addEventListener('click', () => {
      saveDropdown.classList.remove('open');
    });

    // Hook up the two save actions
    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportProject(false); // normal save
    });

    exportWithHistoryBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      exportProject(true); // save including undo/redo history
    });

  const importBtn = document.getElementById('importBtn');
  const importFile = document.getElementById('importFile');
  const exportGifBtn = document.getElementById('exportGifBtn');


  const timelineDiv = document.getElementById('timeline');



  //Canvas
  let backgroundImage = null;
  const defaultEasing = 'none';

  let shapes = [];
  let animation = {
    title: "Untitled",
    author: "Anonymous",
    version: 1,
    canvas: { width: 800, height: 600, background: "#f0f0f0" },
    settings: { frameRate: 30, loop: false },
    keyframes: []
  };

  let currentKeyframeIndex = null;
  let draggingId = null;
  let dragOffsets = new Map();
  let offsetX = 0;
  let offsetY = 0;
  let shapeIdCounter = 1;
  let selectedShapeId = null;
  let multiSelectedShapeIds = new Set();
  let shapeSelectionSource = 'list'; // 'list' or 'canvas'
  let shapeSelectionForce = true;   // override shape outlines

  let isPlaying = false;
  let isLooping = false;
  let isBouncing = false;
  let animationFrameId = null;
  let playbackStartKeyframe = null;

  // freehand drawing state
  let drawMode = null;                // 'freehand' | null
  let isDrawingFreehand = false;
  let freehandPoints = [];            // raw points [{x,y}, ...]
  let _freehandPreviewColor = '#000'; // temporary stroke while drawing

  //UI State
  let lastCursor = null;

  // Shared angle-aim state that persists across updateShapeList() rebuilds
  const angleAim = {
    isAiming: false,
    aimingShapeId: null,
    aimCenter: { x: 0, y: 0 }
  };

  //guards
  let angleAimEventGuard = false;

  const EASERS = {
    smoothstep:        smoothstep,
    easeInQuad:        easeInQuad,
    easeOutQuad:       easeOutQuad,
    easeInOutQuad:     easeInOutQuad,
    easeInCubic:       easeInCubic,
    easeOutCubic:      easeOutCubic,
    easeInOutCubic:    easeInOutCubic,
    easeInQuart:       easeInQuart,
    easeOutQuart:      easeOutQuart,
    easeInOutQuart:    easeInOutQuart,
    easeInQuint:       easeInQuint,
    easeOutQuint:      easeOutQuint,
    easeInOutQuint:    easeInOutQuint,
    easeInSine:        easeInSine,
    easeOutSine:       easeOutSine,
    easeInOutSine:     easeInOutSine,
    easeInExpo:        easeInExpo,
    easeOutExpo:       easeOutExpo,
    easeInOutExpo:     easeInOutExpo,
    easeInElastic:     easeInElastic,
    easeOutElastic:    easeOutElastic,
    easeInOutElastic:  easeInOutElastic,
    easeInBounce:      easeInBounce,
    easeOutBounce:     easeOutBounce,
    easeInOutBounce:   easeInOutBounce,
    parabola:          easeParabola
};


//UNDO/REDO functionality
// History commits are taken from:
// Initial state
// Deleting text / image / shapes / pencil
// Adding   text / image / shapes / pencil
// Object:
  //Move
  //Changing Color
  //Aim Angle Change
  //Reordering
(function(){
  const MAX = 100;
  const H = { history: [], index: -1 };

  function cleanAnimation(anim){
    const copy = JSON.parse(JSON.stringify(anim||{})); // strip functions, _img
    // ensure shapes don’t carry non-serializable _img
    copy.keyframes?.forEach(kf=>{
      kf.shapes = (kf.shapes||[]).map(s=>{
        if (!s) return s;
        const { _img, ...rest } = s;
        return rest;
      });
    });
    return copy;
  }

  function snapshot(){
    // CHANGED: read the real global binding, not window.animation
    return cleanAnimation(animation);
  }

function restore(anim){
    if (!anim) return;

    // 1) Swap in a deep clone so we don’t share refs
    animation = JSON.parse(JSON.stringify(anim));

    // 2) Rehydrate Image() for image shapes stored in keyframes
    animation.keyframes?.forEach(kf=>{
      kf.shapes?.forEach(s=>{
        if (s?.type==='image' && s.src){
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = s.src;
          s._img = img;
        }
      });
    });

    // 3) Sync the live canvas array `shapes` from the active keyframe
    if (Array.isArray(animation.keyframes) && animation.keyframes.length){
      if (currentKeyframeIndex == null) currentKeyframeIndex = 0;
      if (currentKeyframeIndex >= animation.keyframes.length){
        currentKeyframeIndex = animation.keyframes.length - 1;
      }
      const srcShapes = animation.keyframes[currentKeyframeIndex]?.shapes || [];
      // normalize z + clone into the live array (your UI renders from `shapes`)
      shapes = cloneShapes(normalizeZOrder(srcShapes));
    } else {
      shapes = [];
      currentKeyframeIndex = null;
    }

    // 4) Keep IDs monotonic so new shapes don’t collide after restores
    if (typeof shapeIdCounter !== 'undefined'){
      const allIds = animation.keyframes?.flatMap(kf => (kf.shapes||[]).map(s => s.id)) || [];
      shapeIdCounter = allIds.length ? Math.max(...allIds) + 1 : 1;
    }

    // 5) Refresh FPS UI and canvas size if the snapshot changed them
    if (animation.settings && typeof fpsInput !== 'undefined' && fpsInput){
      fpsInput.value = animation.settings.frameRate || 30;
      updatePresetHighlight();
    }
    if (animation.canvas && typeof updateCanvasSize === 'function'){
      updateCanvasSize(animation.canvas.width, animation.canvas.height);
    }

    // 6) Redraw / rebuild panels
    updateShapeList();
    drawAllShapes();
    renderTimeline(currentKeyframeIndex, null);
  }

  function commit(label=''){
    // truncate forward history if we undid
    if (H.index < H.history.length - 1) {
      H.history = H.history.slice(0, H.index + 1);
    }
    H.history.push(snapshot());
    if (H.history.length > MAX) {
      H.history.shift();
    } else {
      H.index++;
    }
    console.log(`✅ commit "${label}" | index=${H.index} len=${H.history.length}`);
  }

  function undo(){
    if (H.index <= 0) return;
    H.index--;
    restore(H.history[H.index]);
    console.log(`↩️ undo -> index=${H.index}`);
  }

  function redo(){
    if (H.index >= H.history.length - 1) return;
    H.index++;
    restore(H.history[H.index]);
    console.log(`↪️ redo -> index=${H.index}`);
  }

  // expose globally
  window.animationHistory = H;
  window.commit = commit;
  window.undo   = undo;
  window.redo   = redo;

  // shortcuts
  window.addEventListener('keydown', e=>{
    const typing = /^(INPUT|TEXTAREA)$/.test(e.target.tagName) || e.target.isContentEditable;
    if (typing) return;
    if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){
      e.preventDefault();
      if (e.shiftKey) redo(); else undo();
    }
  });
})();


function createShape(type, x, y) {
  const size = 50;
  let w = size, h = size;
  if (type === 'rectangle') { w = 80; h = 40; }
  if (type === 'text') {
        const userText = document.getElementById('textContent')?.value || 'Text';

        const fontSize = 16;
        // temporarily set font so we can measure
        ctx.font = `${fontSize}px sans-serif`;
        const metrics = ctx.measureText(userText);
        w = metrics.width;
        h = fontSize;
        //Fixme: This was for line spacing. maybe we bring that back if we support multiline at some point.
        //h = 16 * 1.2;
  }
  const id = shapeIdCounter++;
  return {
    id,
    name: `${type} #${id}`,
    type,
    x,
    y,
    w,
    h,
    color: getRandomColor(),
    mode: 0,
    z: shapes.length,
    locked: true,
    angle: 0,
    text: type === 'text' ? 'Text' : undefined
  };
}

function getRandomColor() {
  const c = ['#e74c3c','#2ecc71','#3498db','#e67e22','#9b59b6','#f1c40f'];
  return c[Math.floor(Math.random() * c.length)];
}

function drawShape(ctx, s, outline = false) {
  const cx = s.x + s.w / 2;
  const cy = s.y + s.h / 2;

  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate((s.angle || 0) * Math.PI / 180);
  ctx.translate(-cx, -cy);

  ctx.fillStyle = s.color;

  if (s.type === 'image') {
    // Ensure image object exists / loads when needed
    if (!(s._img instanceof HTMLImageElement) && s.src) {
      const img = new Image();
      img.onload = () => { s._img = img; drawAllShapes(); };
      img.src = s.src;
      s._img = img; // store immediately so future checks pass instanceof
    }

    if (s._img instanceof HTMLImageElement && s._img.complete && s._img.naturalWidth > 0) {
      ctx.drawImage(s._img, s.x, s.y, s.w, s.h);
      if (outline) {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x, s.y, s.w, s.h);
      }
    }
    // Always restore/return for image shapes (even if not yet loaded)
    ctx.restore();
    return;
  }

  if (s.type === 'freehand') {
    // ⬇️ NEW: draw smoothed freehand path using quadratic curve through midpoints
    const pts = Array.isArray(s.points) ? s.points : [];
    if (pts.length > 1) {
      ctx.strokeStyle = s.color;
      ctx.lineWidth = 2;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length - 1; i++) {
        const midX = (pts[i].x + pts[i+1].x) / 2;
        const midY = (pts[i].y + pts[i+1].y) / 2;
        ctx.quadraticCurveTo(pts[i].x, pts[i].y, midX, midY);
      }
      // tail
      ctx.lineTo(pts[pts.length-1].x, pts[pts.length-1].y);
      ctx.stroke();

      if (outline) {
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(s.x, s.y, s.w, s.h);
      }
    } else if (pts.length === 1) {
      // single dot
      ctx.fillStyle = s.color;
      ctx.beginPath();
      ctx.arc(pts[0].x, pts[0].y, 1.5, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
    return;
  }

  if (s.type !== 'text') {

    switch (s.type) {
      case 'rectangle':
      case 'square':
        ctx.fillRect(s.x, s.y, s.w, s.h);
        if (outline) {
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.strokeRect(s.x, s.y, s.w, s.h);
        }
        break;
      case 'circle':
        ctx.beginPath();
        ctx.ellipse(cx, cy, Math.abs(s.w / 2), Math.abs(s.h / 2), 0, 0, Math.PI * 2);
        ctx.fill();
        if (outline) {
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
      case 'triangle':
        ctx.beginPath();
        ctx.moveTo(s.x + s.w/2, s.y);
        ctx.lineTo(s.x + s.w, s.y + s.h);
        ctx.lineTo(s.x, s.y + s.h);
        ctx.closePath();
        ctx.fill();
        if (outline) {
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
        break;
    }

  }
  else {
    ctx.font = `${s.h}px sans-serif`;
    ctx.textBaseline = 'top';
    ctx.fillText(s.text||'', s.x, s.y);
    if (outline) {
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.strokeText(s.text||'', s.x, s.y);
    }
  }
  ctx.restore();
}


function drawAllShapes(state = shapes) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Fill the canvas with the background color from our animation object.
        ctx.fillStyle = animation.canvas.background || '#f0f0f0'; // Fallback to white
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (backgroundImage) {
        // draw full‐canvas background
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
      }

  const ordered = [...state].sort((a, b) => (a.z ?? 0) - (b.z ?? 0));
  // Only highlight shapes when they're selected from the shapes list, not from canvas
ordered.forEach(s => {
  const selected = multiSelectedShapeIds.has(s.id);
  const showOutline =
    (shapeSelectionForce === true  && selected) ||                   // Force ON: outline selected (canvas or list)
    (shapeSelectionForce === null  && shapeSelectionSource === 'list' && selected); // Auto: list-only
    // Force OFF (false) => no outline
  drawShape(ctx, s, showOutline);
});

}

//────────────────────────────────────────────────
//     ONION SKINNING
//────────────────────────────────────────────────

let onionEnabled = false;

const onionBtn = document.getElementById('onionToggleBtn');
if (onionBtn) {
  onionBtn.addEventListener('click', () => {
    onionEnabled = !onionEnabled;
    onionBtn.classList.toggle('playing', onionEnabled);
    drawAllShapes();
  });
}

// Keyboard shortcut "O"
window.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'o' && !e.ctrlKey && !e.metaKey && !e.altKey) {
    onionEnabled = !onionEnabled;
    if (onionBtn) onionBtn.classList.toggle('playing', onionEnabled);
    drawAllShapes();
  }
});

// Extend existing drawAllShapes() to include onion layers
const _originalDrawAllShapes = drawAllShapes;
drawAllShapes = function(state = shapes) {
  // first draw onion skin layers if enabled
  if (onionEnabled && animation.keyframes.length > 1 && currentKeyframeIndex != null) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = animation.canvas.background || '#f0f0f0';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (backgroundImage) {
      ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
    }

    const prevKF = animation.keyframes[currentKeyframeIndex - 1];
    const nextKF = animation.keyframes[currentKeyframeIndex + 1];

    // Helper for muted shapes
    function drawMuted(shapesArr, color) {
      if (!shapesArr) return;
      const ordered = [...shapesArr].sort((a,b)=>(a.z??0)-(b.z??0));
      ordered.forEach(s=>{
        const clone = { ...s, color: color };
        drawShape(ctx, clone, false);
      });
    }

    // Past (grey)
if (prevKF) drawMuted(prevKF.shapes, 'rgba(200,100,100,0.30)');   // soft warm red-grey for past
if (nextKF) drawMuted(nextKF.shapes, 'rgba(100,160,220,0.30)');   // soft cool blue for future

    // then draw current shapes normally
    const ordered = [...state].sort((a,b)=>(a.z??0)-(b.z??0));
    ordered.forEach(s=>{
      const selected = multiSelectedShapeIds.has(s.id);
      const showOutline =
        (shapeSelectionForce === true  && selected) ||
        (shapeSelectionForce === null  && shapeSelectionSource === 'list' && selected);
      drawShape(ctx, s, showOutline);
    });
  } else {
    // fallback to original logic when disabled
    _originalDrawAllShapes(state);
  }
};

//────────────────────────────────────────────────
//     ONION SKINNING END
//────────────────────────────────────────────────

function updateShapeList() {
  // nicer visuals container class (safe to leave even if CSS not present)
  shapeListDiv.classList.add('shape-list--pro');
  shapeListDiv.innerHTML = '<div class="pro-header"><span>Current Objects</span></div>';

  // ── Angle aiming overlay (same as before) ─────────────────────────────────
  if (!document.getElementById('angleLine')) {
    const line = document.createElement('div');
    line.id = 'angleLine';
    line.style.position = 'absolute';
    line.style.height = '2px';
    line.style.background = 'red';
    line.style.pointerEvents = 'none';
    line.style.transformOrigin = 'left center';
    line.style.display = 'none';
    line.style.zIndex = '9999';
    document.body.appendChild(line);
  }
  const angleLine = document.getElementById('angleLine');

  // mirror shared aim state
  let isAiming = angleAim.isAiming;
  let aimingShapeId = angleAim.aimingShapeId;
  let aimCenter = { x: angleAim.aimCenter.x, y: angleAim.aimCenter.y };

  // top→bottom (highest z first)
  const shapesForDisplay = [...shapes].sort((a, b) => b.z - a.z);

  // shared drag state across all rows (fix)
  let _draggingId = null;

  function renderRows() {
    // remove previous rows (keep header)
    [...shapeListDiv.querySelectorAll('.shape-row')].forEach(el => el.remove());

    shapesForDisplay.forEach(s => {
      const row = document.createElement('div');
      row.className = 'shape-row' + (multiSelectedShapeIds.has(s.id) ? ' selected' : '');
      row.dataset.id = s.id;
      row.draggable = true; // keep for broader browser support

      const colorBlock = (s.type !== 'image')
        ? `<span class="swatch" style="background:${s.color}"></span>`
        : `<span class="swatch" style="background:linear-gradient(45deg,#ddd,#bbb)"></span>`;

      const angleCtl = `
        <label class="mini"><span class="icon">⟳</span>
          <input type="number" id="angle-input_${s.id}" class="angle-input" data-id="${s.id}" value="${s.angle||0}" min="-360" max="9999">
        </label>
        <button type="button" class="mini lock aim-btn" data-id="${s.id}" draggable="false" style="cursor: crosshair;">🔘</button>
      `;

      row.innerHTML = `
        <div class="drag" title="Drag to reorder" aria-label="Drag shape">⠿</div>
        <div class="name">
          ${colorBlock}
          <div class="title" data-id="${s.id}" title="Click to select / Double-click to rename">
            ${s.name || (s.type + ' #' + s.id)}
          </div>
        </div>
<div class="actions">
  <div class="split delete-split" data-id="${s.id}">
    <button type="button" class="btn btn-main delete-main" title="Delete from current keyframe only">🗑</button>

    <div class="dropdown">
      <button type="button" class="btn btn-caret delete-caret" aria-label="More delete options">
        <span class="caret"></span>
      </button>
      <div class="dropdown-menu">
        <button type="button" class="delete-option" data-scope="1" title="Delete from current keyframe only">
          Delete from current keyframe only (default)
        </button>

        <button type="button" class="delete-option" data-scope="2" title="Delete from current and forward keyframes">
          Delete from current & forward keyframes
        </button>

        <button type="button" class="delete-option" data-scope="3" title="Delete from all keyframes">
          Delete from all keyframes
        </button>
      </div>
    </div>
  </div>
</div>
        <div class="meta">
          ${s.type !== 'image' ? `
            <label class="mini"><span class="icon">🎨</span>
              <input type="color" data-id="${s.id}" value="${s.color}">
            </label>` : ''}
          ${s.type==='text' ? `
            <label class="mini"><span class="icon">🔤</span>
              <input type="text" class="text-input" data-id="${s.id}" value="${s.text||''}" style="width:120px;">
            </label>` : ''}
          <label class="mini"><span class="icon">w</span>
            <input type="number" id="w-input_${s.id}" class="w-input" data-id="${s.id}" value="${s.w}" min="1" max="9999">
          </label>
          <label class="mini"><span class="icon">h</span>
            <input type="number" id="h-input_${s.id}" class="h-input" data-id="${s.id}" value="${s.h}" min="1" max="9999">
          </label>
          <button type="button" class="mini lock lock-btn" data-id="${s.id}" title="Lock aspect while resizing">
            ${s.locked?'🔒':'🔓'}
          </button>
          ${angleCtl}
        </div>
      `;

      shapeListDiv.appendChild(row);

      // ── Selection (single / Ctrl|Cmd toggle) ───────────────────────────────
      row.addEventListener('click', (e) => {
        shapeSelectionSource = 'list';
        if (e.target.closest('input,button,.drag')) return;
        const id = s.id;
        if (e.ctrlKey || e.metaKey) {
          if (multiSelectedShapeIds.has(id)) {
            multiSelectedShapeIds.delete(id);
            if (selectedShapeId === id) {
              selectedShapeId = multiSelectedShapeIds.size ? [...multiSelectedShapeIds][0] : null;
            }
          } else {
            multiSelectedShapeIds.add(id);
            selectedShapeId = id;
          }
        } else {
          multiSelectedShapeIds.clear();
          multiSelectedShapeIds.add(id);
          selectedShapeId = id;
        }
        updateShapeList();
        drawAllShapes();
      });

      // ── Rename on dblclick ─────────────────────────────────────────────────
      row.querySelector('.title').addEventListener('dblclick', (e) => {
        e.stopPropagation();
        const id = s.id;
        const shape = shapes.find(x => x.id === id);
        if (!shape) return;
        const newName = prompt("Rename shape:", shape.name || (shape.type + ' #' + shape.id));
        if (newName && newName.trim()) {
          shape.name = newName.trim();
          animation.keyframes.forEach(kf => {
            const sk = kf.shapes.find(o => o.id === id);
            if (sk) sk.name = shape.name;
          });
          updateShapeList();
        }
      });

      // ── Inputs wiring (color/text/w/h/angle/lock) —─────────────────────────
      row.querySelectorAll('input[type="color"]').forEach(inp => {
        inp.oninput = () => {
          const id = parseInt(inp.dataset.id), c = inp.value;
          const ss = shapes.find(o => o.id === id);
          if (!ss || ss.type === 'image') return;
          ss.color = c;
          if (currentKeyframeIndex != null) {
            const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
            if (kf) kf.color = c;
          }
          drawAllShapes();
        };

        // Only commit when user finishes interaction
        inp.addEventListener('change', () => {
          commit('Shape (Color Change)');
        });
      });

      row.querySelectorAll('.text-input').forEach(inp => {
        inp.oninput = () => {
          const id = parseInt(inp.dataset.id, 10);
          const ss = shapes.find(o => o.id === id);
          if (!ss) return;

          ss.text = inp.value;

          // 🔑 Recompute width from actual font size
          ctx.save();
          ctx.font = `${ss.h}px sans-serif`;
          ss.w = ctx.measureText(ss.text || '').width;
          //change the value on the input to the correct one now we've extended the 'shape'. 
          //we avoid updateShapeList() because the refresh will lose focus on the input.
          const wInput = row.querySelector(`.w-input[data-id="${id}"]`);
          if (wInput) wInput.value = Math.round(ss.w);

          ctx.restore();

          if (currentKeyframeIndex != null) {
            const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
            if (kf) {
              kf.text = inp.value;
              kf.w = ss.w; // keep in sync
            }
          }

          drawAllShapes();
        };
      });

      row.querySelectorAll('.w-input').forEach(inp => {
        inp.oninput = () => {
          const id = parseInt(inp.dataset.id);
          const ss = shapes.find(o => o.id === id);
          const newW = parseFloat(inp.value);
          if (!ss || isNaN(newW)) return;
          const oldW = ss.w;
          ss.w = newW;

          if (ss.type === 'freehand' && oldW !== 0 && Array.isArray(ss.points)) {
            const scaleX = newW / oldW;
            ss.points.forEach(p => { p.x = ss.x + (p.x - ss.x) * scaleX; });
          }

          if (ss.locked && oldW !== 0) {
            const aspect = ss.h / oldW;
            const newH = newW * aspect;
            if (ss.type === 'freehand' && ss.h !== newH && Array.isArray(ss.points)) {
              const scaleY = newH / ss.h;
              ss.points.forEach(p => { p.y = ss.y + (p.y - ss.y) * scaleY; });
            }
            ss.h = newH;
            const hInput = row.querySelector(`.h-input[data-id="${id}"]`);
            if (hInput) hInput.value = Math.round(newH);
          }

          if (currentKeyframeIndex != null) {
            const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
            if (kf) {
              kf.w = ss.w; kf.h = ss.h;
              if (kf.type === 'freehand' && Array.isArray(kf.points)) {
                kf.points = ss.points.map(p => ({x:p.x, y:p.y}));
              }
            }
          }
          drawAllShapes();
        };
      });

      row.querySelectorAll('.h-input').forEach(inp => {
        inp.oninput = () => {
          const id = parseInt(inp.dataset.id);
          const ss = shapes.find(o => o.id === id);
          const newH = parseFloat(inp.value);
          if (!ss || isNaN(newH)) return;
          const oldH = ss.h;
          ss.h = newH;

          if (ss.type === 'freehand' && oldH !== 0 && Array.isArray(ss.points)) {
            const scaleY = newH / oldH;
            ss.points.forEach(p => { p.y = ss.y + (p.y - ss.y) * scaleY; });
          }

          if (ss.locked && oldH !== 0) {
            const aspect = ss.w / oldH;
            const newW = newH * aspect;
            if (ss.type === 'freehand' && ss.w !== newW && Array.isArray(ss.points)) {
              const scaleX = newW / ss.w;
              ss.points.forEach(p => { p.x = ss.x + (p.x - ss.x) * scaleX; });
            }
            ss.w = newW;
            const wInput = row.querySelector(`.w-input[data-id="${id}"]`);
            if (wInput) wInput.value = Math.round(newW);
          }

          if (currentKeyframeIndex != null) {
            const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
            if (kf) {
              kf.w = ss.w; kf.h = ss.h;
              if (kf.type === 'freehand' && Array.isArray(kf.points)) {
                kf.points = ss.points.map(p => ({x:p.x, y:p.y}));
              }
            }
          }
          drawAllShapes();
        };
      });

      row.querySelectorAll('.angle-input').forEach(inp => {
        inp.oninput = () => {
          const id = parseInt(inp.dataset.id);
          const ss = shapes.find(o => o.id === id);
          const newAngle = parseFloat(inp.value);
          if (!ss || isNaN(newAngle)) return;
          ss.angle = newAngle;
          if (currentKeyframeIndex != null) {
            const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
            if (kf) kf.angle = newAngle;
          }
          drawAllShapes();
        };
      });

      row.querySelectorAll('.lock-btn').forEach(btn => {
        btn.onclick = () => {
          const id = parseInt(btn.dataset.id);
          const ss = shapes.find(o => o.id === id);
          ss.locked = !ss.locked;
          btn.textContent = ss.locked ? '🔒' : '🔓';
        };
      });

      row.querySelectorAll('.delete-split').forEach(split => {
        const id    = parseInt(split.dataset.id, 10);
        const dd    = split.querySelector('.dropdown');
        const caret = split.querySelector('.delete-caret');
        const main  = split.querySelector('.delete-main');
        const menu  = split.querySelector('.dropdown-menu');

        // Main part = default delete (current keyframe only)
        main.addEventListener('click', (e) => {
          e.stopPropagation();
          deleteShapeWithScope(id, "1");
        });

        // Toggle dropdown
        caret.addEventListener('click', (e) => {
          e.stopPropagation();
          dd.classList.toggle('open');
        });

        // Pick a non-default scope
        menu.addEventListener('click', (e) => {
          const btn = e.target.closest('.delete-option');
          if (!btn) return;
          e.stopPropagation();
          const scope = btn.getAttribute('data-scope'); // "2" or "3"
          deleteShapeWithScope(id, scope);
          dd.classList.remove('open');
        });

        // Close when clicking outside this split
        document.addEventListener('click', (e) => {
          if (!split.contains(e.target)) dd.classList.remove('open');
        });
      });

      // ── Aim button wiring (unchanged) ──────────────────────────────────────
      row.querySelectorAll('.aim-btn').forEach(btn => {
        btn.addEventListener('mousedown', (e) => {
          e.stopPropagation(); e.preventDefault();
          aimingShapeId = parseInt(btn.dataset.id);
          isAiming = true;
          angleAim.aimingShapeId = aimingShapeId;
          angleAim.isAiming = isAiming;
          const rect = btn.getBoundingClientRect();
          aimCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
          angleAim.aimCenter = { x: aimCenter.x, y: aimCenter.y };
          angleLine.style.display = 'block';
          angleLine.style.left = aimCenter.x + 'px';
          angleLine.style.top = aimCenter.y + 'px';
          angleLine.style.width = '0px';
          angleLine.style.transform = 'rotate(0deg)';
        });
      });

      // ── Drag & drop reordering (FIXED: shared _draggingId) ────────────────
      const handle = row.querySelector('.drag');
      handle.setAttribute('draggable', 'true');           // ensure dragstart fires on handle, too
      handle.addEventListener('mousedown', ev => ev.stopPropagation());

      function startDrag(e) {
        // only allow if started on handle
        if (!e.target.closest('.drag')) { e.preventDefault(); return; }
        _draggingId = s.id;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.dropEffect = 'move';
        e.dataTransfer.setData('text/plain', String(s.id)); // required for Safari
        const rect = row.getBoundingClientRect();
        const offX = (e.clientX - rect.left), offY = (e.clientY - rect.top);
        if (e.dataTransfer.setDragImage) e.dataTransfer.setDragImage(row, offX, offY);
      }
      function dragOver(e) {
        if (_draggingId == null) return;
        e.preventDefault();
        row.classList.add('drag-over');
      }
      function dragLeave() { row.classList.remove('drag-over'); }
      function endDrag() { row.classList.remove('drag-over'); if (_draggingId != null) _draggingId = null; }

      function dropOn(e) {
        if (_draggingId == null) return;
        e.preventDefault();
        row.classList.remove('drag-over');

        const draggedId = parseInt(e.dataTransfer.getData('text/plain'), 10) || _draggingId;
        const targetId  = s.id;
        if (!draggedId || draggedId === targetId) { _draggingId = null; return; }

        // build display order (top→bottom), move dragged
        const displayIds = shapesForDisplay.map(x => x.id);
        const fromPos = displayIds.indexOf(draggedId);
        const toPos   = displayIds.indexOf(targetId);
        if (fromPos < 0 || toPos < 0) { _draggingId = null; return; }

        displayIds.splice(toPos, 0, displayIds.splice(fromPos,1)[0]);

        // apply to real data: top gets highest z
        const n = displayIds.length;
        displayIds.forEach((id, i) => {
          const ss = shapes.find(x => x.id === id);
          if (ss) ss.z = n - 1 - i;
        });
        normalizeZOrder(shapes);

        // propagate to keyframes (same prompt)
        if (currentKeyframeIndex != null) {
          const option = prompt(
            'Apply z-index change to:\n' +
            '1 = current keyframe only\n' +
            '2 = all keyframes\n' +
            '3 = current and all future keyframes',
            '1'
          );
          const affectedIndices = (() => {
            if (option === '2') return [...animation.keyframes.keys()];
            if (option === '3') return Array.from({length: animation.keyframes.length - currentKeyframeIndex}, (_, i) => i + currentKeyframeIndex);
            return [currentKeyframeIndex];
          })();
          affectedIndices.forEach(i => {
            const frame = animation.keyframes[i].shapes;
            shapes.forEach(ss => {
              const match = frame.find(k => k.id === ss.id);
              if (match) match.z = ss.z;
            });
            normalizeZOrder(frame);
          });
        }

        // refresh local list & UI
        shapesForDisplay.length = 0;
        shapesForDisplay.push(...[...shapes].sort((a,b)=> b.z - a.z));
        renderRows();
        drawAllShapes();
        commit('Object Reordering')

        _draggingId = null;
      }

      // bind to both row and handle for cross-browser reliability
      row.addEventListener('dragstart', startDrag);
      handle.addEventListener('dragstart', startDrag);
      row.addEventListener('dragover', dragOver);
      row.addEventListener('dragenter', dragOver);
      row.addEventListener('dragleave', dragLeave);
      row.addEventListener('dragend', endDrag);
      row.addEventListener('drop', dropOn);
    });
  }

  renderRows();

  // ── Global aiming listeners (guarded) ─────────────────────────────────────
  if (!angleAimEventGuard) {
    window.addEventListener('mousemove', e => {
      if (!angleAim.isAiming || angleAim.aimingShapeId == null) return;
      const mouseX = e.clientX, mouseY = e.clientY;
      const dx = mouseX - angleAim.aimCenter.x;
      const dy = mouseY - angleAim.aimCenter.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      let angle = Math.atan2(dy, dx) * 180 / Math.PI;
      if (angle < 0) angle += 360;
      angle = Math.round(angle);

      angleLine.style.width = distance + 'px';
      angleLine.style.transform = `rotate(${angle}deg)`;

      const s = shapes.find(o => o.id === angleAim.aimingShapeId);
      if (s) {
        s.angle = angle;
        const input = document.querySelector(`.angle-input[data-id="${angleAim.aimingShapeId}"]`);
        if (input) input.value = angle;
        if (currentKeyframeIndex != null) {
          const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === s.id);
          if (kf) kf.angle = angle;
        }
        drawAllShapes();
      }
    });

    window.addEventListener('mouseup', () => {
      if (angleAim.isAiming) {
        angleAim.isAiming = false;
        angleAim.aimingShapeId = null;
        angleLine.style.display = 'none';
        commit('Object Aim Angle Change')
      }
    });

    angleAimEventGuard = true;
  }
}



function cloneShape(o) {
  return {
    id: o.id,
    type: o.type,
    name: o.name,
    x: o.x, y: o.y,
    w: o.w, h: o.h,
    color: o.color,
    angle: o.angle||0,
    mode: o.mode||0,
    z: o.z||0,
    locked: o.locked??true,
    text: o.text,
    // image fields (serialize src; _img is runtime)
    src: o.src,
    _img: o._img,
    /* ⬇️ NEW: path data for freehand shapes */
    points: o.points ? o.points.map(p => ({x:p.x, y:p.y})) : undefined
  };
}
    
function cloneShapes(arr) { return arr.map(cloneShape); }

// ─── EASING ALGOS ────────────────────────────────────────────────────────
function smoothstep(t) { return t * t * (3 - 2 * t);}
// Quadratic
function easeInQuad(t) { return t * t;}
function easeOutQuad(t) { return t * (2 - t);}
function easeInOutQuad(t) {
  return t < 0.5
    ? 2 * t * t
    : -1 + (4 - 2 * t) * t;
}
// Cubic
function easeInCubic(t) { return t * t * t;}
function easeOutCubic(t) {return (--t) * t * t + 1;}
function easeInOutCubic(t) {
  return t < 0.5
    ? 4 * t * t * t
    : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
}
// Quartic
function easeInQuart(t) { return t * t * t * t;}
function easeOutQuart(t) { return 1 - (--t) * t * t * t;}
function easeInOutQuart(t) {
  return t < 0.5
    ? 8 * t * t * t * t
    : 1 - 8 * (--t) * t * t * t;
}
// Quintic
function easeInQuint(t) { return t * t * t * t * t;}
function easeOutQuint(t) { return 1 + (--t) * t * t * t * t;}
function easeInOutQuint(t) {
  return t < 0.5
    ? 16 * t * t * t * t * t
    : 1 + 16 * (--t) * t * t * t * t;
}
// Sinusoidal
function easeInSine(t) { return 1 - Math.cos((t * Math.PI) / 2);}
function easeOutSine(t) { return Math.sin((t * Math.PI) / 2);}
function easeInOutSine(t) { return 0.5 * (1 - Math.cos(Math.PI * t));}

// Exponential
function easeInExpo(t) { return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));}
function easeOutExpo(t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);}
function easeInOutExpo(t) {
  if (t === 0) return 0;
  if (t === 1) return 1;
  if (t < 0.5) return Math.pow(2, 20 * t - 10) / 2;
  return (2 - Math.pow(2, -20 * t + 10)) / 2;
}
// Elastic
function easeInElastic(t) {
  const c4 = (2 * Math.PI) / 3;
  return t === 0
    ? 0
    : t === 1
    ? 1
    : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
}
function easeOutElastic(t) {
  const c4 = (2 * Math.PI) / 3;
  return t === 0
    ? 0
    : t === 1
    ? 1
    : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
}
function easeInOutElastic(t) {
  const c5 = (2 * Math.PI) / 4.5;
  if (t === 0) return 0;
  if (t === 1) return 1;
  if (t < 0.5)
    return (
      -Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)
    ) / 2;
  return (
    Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)
  ) / 2 + 1;
}
// Bounce
function easeOutBounce(t) {
  const n1 = 7.5625,
        d1 = 2.75;
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    t -= 1.5 / d1;
    return n1 * t * t + 0.75;
  } else if (t < 2.5 / d1) {
    t -= 2.25 / d1;
    return n1 * t * t + 0.9375;
  } else {
    t -= 2.625 / d1;
    return n1 * t * t + 0.984375;
  }
}
function easeInBounce(t) { return 1 - easeOutBounce(1 - t);}
function easeInOutBounce(t) {
  if (t < 0.5) {
    return (1 - easeOutBounce(1 - 2 * t)) / 2;
  }
  return (1 + easeOutBounce(2 * t - 1)) / 2;
}
function easeParabola(t) { return 4 * t * (1 - t);}

function renderTimeline(active = null, playing = null) {
  // opt into pro look
  timelineDiv.classList.add('kf-list--pro');
  timelineDiv.innerHTML = '<div class="pro-header"><span>Keyframes</span></div>';

  animation.keyframes.forEach((kf, i) => {
    if (!kf.name) kf.name = `Keyframe ${i}`;
    kf.frames ??= 30;
    kf.easing ??= defaultEasing;

    const row = document.createElement('div');
    row.className = 'kf-row';
    if (i === active)  row.classList.add('selected');
    if (i === playing) row.classList.add('playing');
    row.dataset.index = i;
    row.draggable = true;

    // meta controls (frames + easing) grouped like shapes “meta”
    row.innerHTML = `
      <div class="drag" title="Drag to reorder" aria-label="Drag keyframe">⠿</div>
      <div class="name">
        <div class="title" title="Click to select / Double-click to rename">${kf.name}</div>
      </div>
      <div class="actions">
        <button class="btn delete-btn" data-index="${i}" 
        title="${animation.keyframes.length === 1 ? 'Cannot delete the last keyframe' : 'Delete'}"
        ${animation.keyframes.length === 1 ? 'disabled' : ''}>
        ${animation.keyframes.length === 1 ? '🚫' : '🗑'}</button>
      </div>
      <div class="meta">
        <label class="mini" title="Duration in frames">
          <span class="icon">⏱</span>
          <input type="number" id="frame-input_${i}" class="frame-input" data-index="${i}" value="${kf.frames}" min="1" style="width:56px;">
        </label>
        <label class="mini" title="Easing">
          <span class="icon">∿</span>
          <select id="easing-select_${i}" class="easing-select" data-index="${i}">
            <optgroup label="No Interpolation">
              <option value="none"${kf.easing==='none'?' selected':''}>None</option>
            </optgroup>
            <optgroup label="Linear Interpolations">
              <option value="linear"${kf.easing==='linear'?' selected':''}>Linear</option>
              <option value="smoothstep"${kf.easing==='smoothstep'?' selected':''}>Smoothstep</option>
              <option value="easeInOutQuad"${kf.easing==='easeInOutQuad'?' selected':''}>Quad In-Out</option>
              <option value="easeInQuad"${kf.easing==='easeInQuad'?' selected':''}>Quad In</option>
              <option value="easeOutQuad"${kf.easing==='easeOutQuad'?' selected':''}>Quad Out</option>
              <option value="easeInOutCubic"${kf.easing==='easeInOutCubic'?' selected':''}>Cubic In-Out</option>
              <option value="easeInCubic"${kf.easing==='easeInCubic'?' selected':''}>Cubic In</option>
              <option value="easeOutCubic"${kf.easing==='easeOutCubic'?' selected':''}>Cubic Out</option>
              <option value="easeInOutQuart"${kf.easing==='easeInOutQuart'?' selected':''}>Quart In-Out</option>
              <option value="easeInQuart"${kf.easing==='easeInQuart'?' selected':''}>Quart In</option>
              <option value="easeOutQuart"${kf.easing==='easeOutQuart'?' selected':''}>Quart Out</option>
              <option value="easeInOutQuint"${kf.easing==='easeInOutQuint'?' selected':''}>Quint In-Out</option>
              <option value="easeInQuint"${kf.easing==='easeInQuint'?' selected':''}>Quint In</option>
              <option value="easeOutQuint"${kf.easing==='easeOutQuint'?' selected':''}>Quint Out</option>
              <option value="easeInOutSine"${kf.easing==='easeInOutSine'?' selected':''}>Sine In-Out</option>
              <option value="easeInSine"${kf.easing==='easeInSine'?' selected':''}>Sine In</option>
              <option value="easeOutSine"${kf.easing==='easeOutSine'?' selected':''}>Sine Out</option>
              <option value="easeInOutExpo"${kf.easing==='easeInOutExpo'?' selected':''}>Expo In-Out</option>
              <option value="easeInExpo"${kf.easing==='easeInExpo'?' selected':''}>Expo In</option>
              <option value="easeOutExpo"${kf.easing==='easeOutExpo'?' selected':''}>Expo Out</option>
            </optgroup>
            <optgroup label="Dynamic Interpolations">
              <option value="parabola"${kf.easing==='parabola'?' selected':''}>Parabola</option>
              <option value="easeInOutBounce"${kf.easing==='easeInOutBounce'?' selected':''}>Bounce In-Out</option>
              <option value="easeInBounce"${kf.easing==='easeInBounce'?' selected':''}>Bounce In</option>
              <option value="easeOutBounce"${kf.easing==='easeOutBounce'?' selected':''}>Bounce Out</option>
              <option value="easeInOutElastic"${kf.easing==='easeInOutElastic'?' selected':''}>Elastic In-Out</option>
              <option value="easeInElastic"${kf.easing==='easeInElastic'?' selected':''}>Elastic In</option>
              <option value="easeOutElastic"${kf.easing==='easeOutElastic'?' selected':''}>Elastic Out</option>
            </optgroup>
            <optgroup label="Effects">
              <option value="spiral"${kf.easing==='spiral'?' selected':''}>Spiral In</option>
              <option value="wavy"${kf.easing==='wavy'?' selected':''}>Wavy In</option>
            </optgroup>
          </select>
        </label>
      </div>
    `;

    // frames
    row.querySelector('.frame-input').addEventListener('input', e => {
      const val = parseInt(e.target.value, 10);
      if (!isNaN(val) && val > 0) animation.keyframes[i].frames = val;
    });
    // easing
    row.querySelector('.easing-select').addEventListener('change', e => {
      animation.keyframes[i].easing = e.target.value;
    });

    // select keyframe (click on row except inputs/buttons/drag)
    row.addEventListener('click', e => {
      if (isPlaying) return;
      if (e.target.closest('.actions, .meta')) return;
      currentKeyframeIndex = i;
      shapes = cloneShapes(animation.keyframes[i].shapes);
      selectedShapeId = null;
      updateShapeList(); drawAllShapes(); renderTimeline(currentKeyframeIndex, null);
    });

    // rename on double-click of title
    row.querySelector('.title').addEventListener('dblclick', e => {
      e.stopPropagation();
      const newName = prompt("Rename keyframe:", kf.name);
      if (newName && newName.trim()) { kf.name = newName.trim(); renderTimeline(active, playing); }
    });

    // play/delete
    row.querySelector('.delete-btn').onclick = e => {
      e.stopPropagation();
      if (animation.keyframes.length <= 1) return;
      animation.keyframes.splice(i, 1);
      currentKeyframeIndex = Math.max(0, currentKeyframeIndex - (i <= currentKeyframeIndex ? 1 : 0));
      shapes = cloneShapes(animation.keyframes[currentKeyframeIndex].shapes);
      updateShapeList(); drawAllShapes(); renderTimeline(currentKeyframeIndex, null);
    };

    // Hide tween-related controls on the final keyframe
    //if (i === animation.keyframes.length - 1) {
    //  const tweenControls = row.querySelectorAll('.frame-input, .easing-select');
    //  tweenControls.forEach(el => {
    //    el.disabled = true;    // or el.style.display = 'none';
    //  });
    //}

    // drag & drop reorder (use the same .drag convention as shapes)
    const handle = row.querySelector('.drag');
    handle.setAttribute('draggable', 'true');
    handle.addEventListener('mousedown', ev => ev.stopPropagation());

    function startDrag(e) {
      if (!e.target.closest('.drag')) { e.preventDefault(); return; }
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.dropEffect = 'move';
      e.dataTransfer.setData('text/plain', String(i));
      row.classList.add('drag-over');
      const rect = row.getBoundingClientRect();
      const offX = e.clientX - rect.left, offY = e.clientY - rect.top;
      if (e.dataTransfer.setDragImage) e.dataTransfer.setDragImage(row, offX, offY);
    }
    function dragOver(e){ e.preventDefault(); row.classList.add('drag-over'); }
    function dragLeave(){ row.classList.remove('drag-over'); }
    function dropOn(e){
      e.preventDefault(); row.classList.remove('drag-over');
      const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
      const toIndex   = parseInt(row.dataset.index, 10);
      if (Number.isNaN(fromIndex) || Number.isNaN(toIndex) || fromIndex === toIndex) return;

      const [moved] = animation.keyframes.splice(fromIndex, 1);
      animation.keyframes.splice(toIndex, 0, moved);

      if (currentKeyframeIndex === fromIndex) {
        currentKeyframeIndex = toIndex;
      } else if (currentKeyframeIndex > fromIndex && currentKeyframeIndex <= toIndex) {
        currentKeyframeIndex--;
      } else if (currentKeyframeIndex < fromIndex && currentKeyframeIndex >= toIndex) {
        currentKeyframeIndex++;
      }

      shapes = cloneShapes(animation.keyframes[currentKeyframeIndex].shapes);
      updateShapeList(); drawAllShapes(); renderTimeline(currentKeyframeIndex, null);
    }
    function endDrag(){ row.classList.remove('drag-over'); }

    row.addEventListener('dragstart', startDrag);
    handle.addEventListener('dragstart', startDrag);
    row.addEventListener('dragover', dragOver);
    row.addEventListener('dragenter', dragOver);
    row.addEventListener('dragleave', dragLeave);
    row.addEventListener('drop', dropOn);
    row.addEventListener('dragend', endDrag);

    timelineDiv.appendChild(row);
  });

  if (playing){document.querySelector('.kf-row.playing')?.scrollIntoView({ block: 'center' });}

  //wont exist on first render
  if (typeof updatePlayTimer === 'function') {
    updatePlayTimer();
  }
}

function interpolateShapes(a, b, t) {
  return a.shapes.map(sa => {
    const sb = b.shapes.find(o => o.id === sa.id);
    if (!sb) return sa;

    const out = { ...sa };            // carry all fields (incl. src/_img/points)
    out.x     = sa.x + (sb.x - sa.x) * t;
    out.y     = sa.y + (sb.y - sa.y) * t;
    out.w     = sa.w + (sb.w - sa.w) * t;
    out.h     = sa.h + (sb.h - sa.h) * t;
    out.angle = interpolateAngle(sa.angle || 0, sb.angle || 0, t);
    out.z     = sa.z ?? 0;

    /* ⬇️ NEW: move (and scale) freehand points with the bbox */
    if (sa.type === 'freehand' && Array.isArray(sa.points)) {
      const scaleX = (sa.w !== 0) ? (out.w / sa.w) : 1;
      const scaleY = (sa.h !== 0) ? (out.h / sa.h) : 1;
      out.points = sa.points.map(p => ({
        x: out.x + (p.x - sa.x) * scaleX,
        y: out.y + (p.y - sa.y) * scaleY
      }));
    }

    return out;
  });
}



function interpolateShapesSpiral(a, b, t) {
  const rotations = 1;
  return a.shapes.map(sa => {
    const sb = b.shapes.find(o => o.id === sa.id);
    if (!sb) return sa;

    const dx = sb.x - sa.x, dy = sb.y - sa.y;
    const dist = Math.hypot(dx, dy);
    const baseAng = Math.atan2(dy, dx);
    const ang = baseAng + rotations * 2 * Math.PI * t;
    const r   = dist * (1 - t);
    const x   = sb.x - r * Math.cos(ang);
    const y   = sb.y - r * Math.sin(ang);

    const out = { ...sa };
    out.x     = x;
    out.y     = y;
    out.w     = sa.w + (sb.w - sa.w) * t;
    out.h     = sa.h + (sb.h - sa.h) * t;
    out.angle = interpolateAngle(sa.angle || 0, sb.angle || 0, t);
    out.z     = sa.z ?? 0;

    /* ⬇️ NEW: move/scale freehand points with the interpolated bbox */
    if (sa.type === 'freehand' && Array.isArray(sa.points)) {
      const scaleX = (sa.w !== 0) ? (out.w / sa.w) : 1;
      const scaleY = (sa.h !== 0) ? (out.h / sa.h) : 1;
      out.points = sa.points.map(p => ({
        x: out.x + (p.x - sa.x) * scaleX,
        y: out.y + (p.y - sa.y) * scaleY
      }));
    }

    return out;
  });
}

function interpolateShapesWavy(a, b, t) {
  return a.shapes.map(sa => {
    const sb = b.shapes.find(o => o.id === sa.id);
    if (!sb) return sa;

    // 1) linear baseline
    const x0 = sa.x, y0 = sa.y;
    const x1 = sb.x, y1 = sb.y;
    const xLin = x0 + (x1 - x0) * t;
    const yLin = y0 + (y1 - y0) * t;

    // 2) perpendicular unit vector
    let dx = x1 - x0, dy = y1 - y0;
    let nx = -dy, ny = dx;
    const L = Math.hypot(nx, ny) || 1;
    nx /= L; ny /= L;

    // 3) wave offset (frequency and envelope)
    const amplitude = 50;      // px
    const frequency = 3;       // waves per segment
    const offset = Math.sin(2 * Math.PI * frequency * t) * amplitude * Math.sin(Math.PI * t);

    // 4) final position
    const out = { ...sa };
    out.x     = xLin + nx * offset;
    out.y     = yLin + ny * offset;
    out.w     = sa.w + (sb.w - sa.w) * t;
    out.h     = sa.h + (sb.h - sa.h) * t;
    out.angle = interpolateAngle(sa.angle || 0, sb.angle || 0, t);
    out.z     = sa.z ?? 0;

    /* ⬇️ NEW: move/scale freehand points with the interpolated bbox */
    if (sa.type === 'freehand' && Array.isArray(sa.points)) {
      const scaleX = (sa.w !== 0) ? (out.w / sa.w) : 1;
      const scaleY = (sa.h !== 0) ? (out.h / sa.h) : 1;
      out.points = sa.points.map(p => ({
        x: out.x + (p.x - sa.x) * scaleX,
        y: out.y + (p.y - sa.y) * scaleY
      }));
    }

    return out;
  });
}

function interpolateAngle(a1, a2, t) {
  //we intentionally do not take the short path between a1->a2, given we want to support shapes having mutliple rotations between 2 keyframes
  return a1 + (a2 - a1) * t;
}

// ─── 3) UPDATED playAnimation TO RESPECT EASING + FIXED FRAME TIMING ──────────
function playAnimation(mode = 'once') {
  if (animation.keyframes.length < 2 || isPlaying) return;
  lastCursor = canvas.style.cursor;
  isPlaying  = true;

  if (!document.fullscreenElement){
    canvas.style.cursor = 'wait';
  }
  else{
    canvas.style.cursor = 'none';
  }
  
  isLooping  = (mode === 'loop');
  isBouncing = (mode === 'bounce');

  loopBtn.classList.remove('playing');
  bounceBtn.classList.remove('playing');

  newPlayBtn.dataset.state = 'stop';
  if (mode === 'loop')   loopBtn.classList.add('playing');
  if (mode === 'bounce') bounceBtn.classList.add('playing');

  let segments = [];
  if (mode === 'bounce') {
    for (let i = 0; i < animation.keyframes.length - 1; i++) segments.push([i, i+1]);
    for (let i = animation.keyframes.length - 1; i > 0;    i--) segments.push([i, i-1]);
  } else {
    for (let i = 0; i < animation.keyframes.length - 1; i++) segments.push([i, i+1]);
    if (mode === 'loop' && animation.keyframes.length > 2)
      segments.push([animation.keyframes.length - 1, 0]);
  }

  playbackStartKeyframe = Math.max(0, currentKeyframeIndex||0);
  let segmentIndex = playbackStartKeyframe;

  selectedShapeId       = null;
  currentKeyframeIndex  = null;
  renderTimeline(null, null);

  //fixed-rate frame timing (user-configurable via animation.settings.frameRate)
  const targetFps       = Math.max(1, Math.floor((animation.settings && animation.settings.frameRate) || 30));
  const frameDurationMs = 1000 / targetFps;
  let lastTime          = null;
  let accumulator       = 0;

  let t = 0;               // how many frames have been rendered in current segment (0..steps-1)
  let _renderedOnce = false;

  function step(now) {
    if (!isPlaying || segmentIndex >= segments.length) {
      stopAnimation();
      return;
    }

    // ⬇️ NEW: accumulate time and only advance a “step” when enough ms have passed
    if (lastTime == null) lastTime = now;
    const delta = now - lastTime;
    lastTime = now;
    accumulator += delta;

    // If we haven’t reached the next frame time and we already rendered once, wait.
    if (accumulator < frameDurationMs && _renderedOnce) {
      animationFrameId = requestAnimationFrame(step);
      return;
    }

    // Consume exactly one frame’s worth of time (don’t try to “catch up” multiple steps at once)
    if (accumulator >= frameDurationMs) {
      accumulator -= frameDurationMs;
    }

    const [fromIdx, toIdx] = segments[segmentIndex];
    const a = animation.keyframes[fromIdx];
    const b = animation.keyframes[toIdx];

    // ← use per-keyframe frames & easing
    const steps  = a.frames || 30;
    const rawT   = t / steps;

    const easer  = EASERS[a.easing] || (x => x);
    const easedT = easer(rawT);

    renderTimeline(null, fromIdx);
    let interp;
    
    if (a.easing === 'none') {
      // Hold on A for frames 0..steps-2, then cut to B on the last frame
      const isLastFrame = (t >= steps - 1);
      interp = isLastFrame ? b.shapes : a.shapes; // (Optionally: cloneShapes(...) if you want immutability)
    }else if (a.easing === 'spiral') {
      interp = interpolateShapesSpiral(a, b, easedT);
    } else if (a.easing === 'wavy') {
      interp = interpolateShapesWavy(a, b, easedT);
    } else {
      interp = interpolateShapes(a, b, easedT);
    }
    // Fixme: This keeps shapes + UI in sync during playback but is EXPENSIVE.
    shapes = cloneShapes(interp);
    updateShapeList();

    drawAllShapes(interp);


    //timer overlay start
// ⬇️ show current playback time (for timer overlay)
const fps = targetFps;
let currentFrame = Math.max(1, currentKeyframeIndex||1);

// sum completed segments
for (let i = 0; i < segmentIndex; i++) {
  const fromKf = animation.keyframes[segments[i][0]];
  currentFrame += fromKf.frames || 0;
}

// add current frame within the active segment
currentFrame += t;

// update play button timer
updatePlayTimer(currentFrame);
//timer overlay end



    _renderedOnce = true;

    t++;
    if (t < steps) {           // was: t <= steps
      animationFrameId = requestAnimationFrame(step);
    } else {
      t = 0;
      segmentIndex++;
      if (segmentIndex >= segments.length) {
        if (isLooping || isBouncing) {
          segmentIndex = 0;
          animationFrameId = requestAnimationFrame(step);
        } else {

          // NEW: render the very final keyframe once before stopping
          const lastPair = segments[segments.length - 1];
          if (lastPair) {
            const lastToIdx = lastPair[1];
            drawAllShapes(animation.keyframes[lastToIdx].shapes);
          }
          
          stopAnimation();
        }
      } else {
        animationFrameId = requestAnimationFrame(step);
      }
    }
  }

  selectedShapeId      = null;
  currentKeyframeIndex = null;
  animationFrameId = requestAnimationFrame(step);
}


function enableFreehandMode(){
  drawMode = 'freehand';
  isDrawingFreehand = false;
  freehandPoints = [];
  _freehandPreviewColor = getRandomColor();
  canvas.style.cursor = 'crosshair';
}

function exitFreehandMode(){
  drawMode = null;
  canvas.style.cursor = 'pointer';
  freehandPoints = [];
}

  /* ⬇️ NEW: draw a live, smoothed preview while dragging */
function drawFreehandPreview(points, color){
  if (!points || points.length < 1) return;
  drawAllShapes(); // clear + redraw existing shapes as backdrop

  ctx.save();
  ctx.strokeStyle = color || '#000';
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  if (points.length === 1) {
    ctx.beginPath();
    ctx.arc(points[0].x, points[0].y, 1.5, 0, Math.PI*2);
    ctx.fillStyle = color || '#000';
    ctx.fill();
    ctx.restore();
    return;
  }

  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length - 1; i++) {
    const midX = (points[i].x + points[i+1].x) / 2;
    const midY = (points[i].y + points[i+1].y) / 2;
    ctx.quadraticCurveTo(points[i].x, points[i].y, midX, midY);
  }
  ctx.lineTo(points[points.length-1].x, points[points.length-1].y);
  ctx.stroke();
  ctx.restore();
}

function stopAnimation() {
  isPlaying = false;
  isLooping = false;
  isBouncing = false;

  newPlayBtn.dataset.state = 'play';
  loopBtn.classList.remove('playing');
  bounceBtn.classList.remove('playing');

  cancelAnimationFrame(animationFrameId);
  canvas.style.cursor = lastCursor || '';

  renderTimeline(currentKeyframeIndex, null);
  
  if (playbackStartKeyframe != null) {
    currentKeyframeIndex = playbackStartKeyframe;
    shapes = cloneShapes(animation.keyframes[currentKeyframeIndex].shapes);
    renderTimeline(currentKeyframeIndex, null);
    updateShapeList();
    playbackStartKeyframe = null; // Reset for future runs
  }
  document.querySelector('.kf-row.selected')?.scrollIntoView({ block: 'center' });
  drawAllShapes();
}

newPlayBtn.onclick = () => {
  (newPlayBtn.dataset.state === 'play') ? playAnimation('once') : stopAnimation();
  updatePlayTimer(0);
}
loopBtn.onclick = () => playAnimation('loop');
bounceBtn.onclick = () => playAnimation('bounce');

fullscreenBtn.onclick = () => {
  if (!document.fullscreenElement) {
    canvas.requestFullscreen().catch(err => {
      alert(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
};

demoBtn.onclick = () => {
  //demo is defined in the default_animation script at the start
  if (typeof demo === 'undefined') { alert('Demo not available.'); return; }
  loadKeyframesFromJSON(JSON.stringify(demo, null, 2));
};


bgInput.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  const url = URL.createObjectURL(file);
  img.onload = () => {
    backgroundImage = img;
    URL.revokeObjectURL(url);
    drawAllShapes();
  };
  img.src = url;
};

clearBgBtn.onclick = () => {
  animation.canvas.background = '#f0f0f0';
  bgColorInput.value = '#f0f0f0';
  backgroundImage = null;
  if (animation.canvas) delete animation.canvas.backgroundImageSrc;
  document.getElementById('bgInput').value = "";
  drawAllShapes();
};

// Update canvas background color live when the color picker changes
bgColorInput.addEventListener('input', () => {
  animation.canvas.background = bgColorInput.value;
  drawAllShapes();
});

const imageInput = document.getElementById('imageInput');

function addObject(type){
  if (type !== 'image') {
    const s = createShape(type, 100 + Math.random() * 500, 100 + Math.random() * 300);

    if (type === 'text') {
      s.text = document.getElementById('textContent').value;
    }

    shapes.push(s);
    if (currentKeyframeIndex != null) {
      for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
        animation.keyframes[i].shapes.push(cloneShape(s));
      }
    }

    // Automatically select the new shape.
    multiSelectedShapeIds.clear();
    multiSelectedShapeIds.add(s.id);
    selectedShapeId = s.id;
    shapeSelectionSource = 'list'; // Ensure selection outline appears.

    updateShapeList();
    drawAllShapes();
    commit('New Object ('+type+')');
    return;
  }

  // image path
  imageInput.value = '';
  imageInput.click();
}

function isDragging() {
  return draggingId !== null || (dragOffsets && dragOffsets.size > 0);
}

function makeShortUUID() {
  return crypto.randomUUID().split('-')[0];
}

function makeUUID() {
  return crypto.randomUUID();
}

imageInput.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = evt => {
    const dataUrl = evt.target.result; // base64
    const img = new Image();
    img.onload = () => {
      // initial size (fit-ish)
      const maxW = 200, maxH = 200;
      let w = img.naturalWidth, h = img.naturalHeight;
      const scale = Math.min(1, maxW / w, maxH / h);
      w = Math.max(1, Math.round(w * scale));
      h = Math.max(1, Math.round(h * scale));

      const s = {
        id: shapeIdCounter++,
        type: 'image',
        x: 100 + Math.random() * 400,
        y: 100 + Math.random() * 250,
        w, h,
        angle: 0,
        z: shapes.length,
        locked: true,
        mode: 0,
        // image-specific
        src: dataUrl,     // serialized in JSON
        _img: img         // runtime cache (not serialized)
      };

      shapes.push(s);
      if (currentKeyframeIndex != null) {
        for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
          animation.keyframes[i].shapes.push(cloneShape(s));
        }
      }

      updateShapeList();
      drawAllShapes();
      commit('New Object (image)');
    };
    img.src = dataUrl;
  };
  reader.readAsDataURL(file);
};

addKeyframeBtn.onclick = () => {
  shapes = [];
  const newKeyframe = {
    id: makeShortUUID(),
    name: `Keyframe ${animation.keyframes.length}`,
    shapes: [],
    frames: 30
 };
  animation.keyframes.push(newKeyframe);
  currentKeyframeIndex = animation.keyframes.length - 1;
  updateShapeList();
  drawAllShapes();
  renderTimeline(currentKeyframeIndex, null);
  commit('Blank Keyframe');
};

cloneKeyframeBtn.onclick = () => {
  // clone shapes from the current keyframe (or from the live canvas)
  const from = currentKeyframeIndex != null
    ? cloneShapes(animation.keyframes[currentKeyframeIndex].shapes)
    : cloneShapes(shapes);

  // inherit the current keyframe’s frames & easing (or default if none)
  const inheritedName = currentKeyframeIndex != null
    ? animation.keyframes[currentKeyframeIndex].name
    : `Keyframe ${animation.keyframes.length}`;

  const inheritedFrames = currentKeyframeIndex != null
    ? animation.keyframes[currentKeyframeIndex].frames
    : 30;
  const inheritedEasing = currentKeyframeIndex != null
    ? animation.keyframes[currentKeyframeIndex].easing
    : defaultEasing;

  const newKeyframe = {
    id: makeShortUUID(),
    name: inheritedName,
    shapes: from,
    frames: inheritedFrames,
    easing: inheritedEasing
  };
  animation.keyframes.push(newKeyframe);
  currentKeyframeIndex = animation.keyframes.length - 1;
  shapes = cloneShapes(from);

  updateShapeList();
  drawAllShapes();
  renderTimeline(currentKeyframeIndex, null);
  commit('Cloned Keyframe');
};

let mouseDownPos = null;
let mouseDownOnShapeId = null;     // NEW: which shape (if any) we pressed on

function normalizeZOrder(list = shapes) {
  // Sort the shapes by their current z (lowest → highest)
  list.sort((a, b) => (a.z ?? 0) - (b.z ?? 0));

  // Reassign compact z values 0..N-1 in sorted order
  list.forEach((s, i) => s.z = i);

  return list;
}

canvas.addEventListener('mousedown', e => {
  if (isPlaying){return;}

  /* ⬇️ NEW: freehand start */
  if (drawMode === 'freehand') {
    const rect = canvas.getBoundingClientRect();
    const m = _mouseToCanvasSpace(e);
    isDrawingFreehand = true;
    freehandPoints = [m];
    drawFreehandPreview(freehandPoints, _freehandPreviewColor);
    return; // do not trigger selection/drag logic while drawing
  }

  dragOffsets.clear();
  const rect = canvas.getBoundingClientRect();
  const m = _mouseToCanvasSpace(e);
  
  // Store mouse down position to detect if user moved mouse
  mouseDownPos = { x: m.x, y: m.y };
  mouseDownOnShapeId  = null;                // NEW

  let clickedShapeId = null;
  
  // Find topmost shape under mouse
  // ← NEW: use z-sorted copy for hit-test so the highest z (drawn last) is checked first
  const hitOrder = [...shapes].sort((a, b) => (a.z ?? 0) - (b.z ?? 0));
  for (let i = hitOrder.length - 1; i >= 0; i--) {
    const s = hitOrder[i];
    const inside = s.type === 'circle'
      ? ((m.x - (s.x + s.w / 2)) ** 2 / (s.w / 2) ** 2 + (m.y - (s.y + s.h / 2)) ** 2 / (s.h / 2) ** 2 <= 1)
      //previous code, without rotation:
      //: (m.x >= s.x && m.x <= s.x + s.w && m.y >= s.y && m.y <= s.y + s.h);
      :  (function(){
          const cx = s.x + s.w/2, cy = s.y + s.h/2;
          const px = m.x - cx,     py = m.y - cy;
          const ang = -((s.angle||0) * Math.PI/180);
          const cosA = Math.cos(ang), sinA = Math.sin(ang);
          const rx = px*cosA - py*sinA;
          const ry = px*sinA + py*cosA;
          const tx = rx + cx, ty = ry + cy;

          if (s.type === 'triangle') {
            // matches your draw: top center, bottom-right, bottom-left
            const Ax = s.x + s.w/2, Ay = s.y;
            const Bx = s.x + s.w,   By = s.y + s.h;
            const Cx = s.x,         Cy = s.y + s.h;

            // barycentric test
            const v0x = Cx - Ax, v0y = Cy - Ay;
            const v1x = Bx - Ax, v1y = By - Ay;
            const v2x = tx - Ax, v2y = ty - Ay;

            const dot00 = v0x*v0x + v0y*v0y;
            const dot01 = v0x*v1x + v0y*v1y;
            const dot02 = v0x*v2x + v0y*v2y;
            const dot11 = v1x*v1x + v1y*v1y;
            const dot12 = v1x*v2x + v1y*v2y;

            const denom = (dot00 * dot11 - dot01 * dot01);
            if (denom === 0) return false; // degenerate triangle
            const invDen = 1 / denom;
            const u = (dot11 * dot02 - dot01 * dot12) * invDen;
            const v = (dot00 * dot12 - dot01 * dot02) * invDen;

            return (u >= 0 && v >= 0 && (u + v) <= 1);
          }

          // rectangles/squares/images/text/freehand → rotated AABB
          return (tx >= s.x && tx <= s.x + s.w && ty >= s.y && ty <= s.y + s.h);
        })();

    if (inside) {
      clickedShapeId = s.id;
      break;
    }
  }

  mouseDownOnShapeId = clickedShapeId;       // NEW

  if (clickedShapeId) {
    //canvas.style.cursor = 'grabbing';
    // User clicked on a shape
    shapeSelectionSource = 'canvas';

    const isSelected = multiSelectedShapeIds.has(clickedShapeId);

    if (e.ctrlKey || e.metaKey) {
      // NEW: Defer toggle to mouseup unless it’s just a click.
      // If the clicked shape is already selected, prep drag for the whole selection now.
      if (isSelected) {
        for (const s of shapes.filter(shape => multiSelectedShapeIds.has(shape.id))) {
          dragOffsets.set(s.id, { dx: m.x - s.x, dy: m.y - s.y });
        }
      }
      // If it isn’t selected, don’t change selection yet and don’t set dragOffsets.
      // A small move will be treated as a click+toggle on mouseup; a real drag won’t toggle.
    } else {
      // No modifier: if clicking inside an already-selected shape, keep the whole selection.
      if (isSelected) {
        for (const s of shapes.filter(shape => multiSelectedShapeIds.has(shape.id))) {
          dragOffsets.set(s.id, { dx: m.x - s.x, dy: m.y - s.y });
        }
      } else {
        // Regular click on an unselected shape: select only it immediately (matches left panel),
        // and prep drag for just that shape.
        multiSelectedShapeIds.clear();
        multiSelectedShapeIds.add(clickedShapeId);
        selectedShapeId = clickedShapeId;

        const s = shapes.find(sh => sh.id === clickedShapeId);
        if (s) dragOffsets.set(s.id, { dx: m.x - s.x, dy: m.y - s.y });
      }
    }
  } else {
    // User clicked on empty space
    if (multiSelectedShapeIds.size > 0) {
      // If shapes are selected, set up drag for them (allows dragging from empty space)
      for (const s of shapes.filter(shape => multiSelectedShapeIds.has(shape.id))) {
        dragOffsets.set(s.id, { dx: m.x - s.x, dy: m.y - s.y });
      }
    }
  }

  updateShapeList();
  drawAllShapes();
});



canvas.addEventListener('mousemove', e => {
  if (isPlaying){return;}

  /* ⬇️ NEW: freehand live capture */
  if (drawMode === 'freehand' && isDrawingFreehand) {
    const rect = canvas.getBoundingClientRect();
    const m = _mouseToCanvasSpace(e);
    const last = freehandPoints[freehandPoints.length - 1];
    // add points only if moved a few px to reduce noise
    if (!last || Math.hypot(m.x - last.x, m.y - last.y) >= 1) {
      freehandPoints.push(m);
      drawFreehandPreview(freehandPoints, _freehandPreviewColor);
    }
    return;
  }

  if (dragOffsets.size > 0) {
    const rect = canvas.getBoundingClientRect();
    const m = _mouseToCanvasSpace(e);

    let changed = false;

    for (const [id, { dx, dy }] of dragOffsets.entries()) {
      const s = shapes.find(o => o.id === id);
      if (!s) continue;

      const newX = m.x - dx;
      const newY = m.y - dy;
      const dX = newX - s.x;
      const dY = newY - s.y;

      if (s.x !== newX || s.y !== newY) {
        s.x = newX;
        s.y = newY;

        /* ⬇️ NEW: translate freehand points with the bbox */
        if (s.type === 'freehand' && Array.isArray(s.points)) {
          s.points.forEach(p => { p.x += dX; p.y += dY; });
        }

        changed = true;
      }

      if (currentKeyframeIndex != null) {
        const kf = animation.keyframes[currentKeyframeIndex].shapes.find(o => o.id === id);
        if (kf) {
          kf.x = s.x;
          kf.y = s.y;

          /* ⬇️ mirror freehand points in keyframe */
          if (kf.type === 'freehand' && Array.isArray(kf.points)) {
            kf.points.forEach(p => { p.x += dX; p.y += dY; });
          }
        }
      }
    }

    if (changed) {
      drawAllShapes();
    }
  }
});


canvas.addEventListener('mouseup', e => {
  if (isPlaying){return;}

  /* ⬇️ NEW: finalize freehand shape */
  if (drawMode === 'freehand' && isDrawingFreehand) {
    isDrawingFreehand = false;

    // compute bbox
    if (freehandPoints.length) {
      const xs = freehandPoints.map(p => p.x);
      const ys = freehandPoints.map(p => p.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const w = Math.max(1, Math.round(maxX - minX));
      const h = Math.max(1, Math.round(maxY - minY));

      const id = shapeIdCounter++;
      const s = {
        id,
        type: 'freehand',
        name: `path #${id}`,
        x: minX,
        y: minY,
        w, h,
        color: _freehandPreviewColor,
        angle: 0,
        z: shapes.length,
        locked: true,
        mode: 0,
        points: freehandPoints.map(p => ({x:p.x, y:p.y}))
      };

      shapes.push(s);
      if (currentKeyframeIndex != null) {
        for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
          animation.keyframes[i].shapes.push(cloneShape(s));
        }
      }

      // select the new path
      multiSelectedShapeIds.clear();
      multiSelectedShapeIds.add(s.id);
      selectedShapeId = s.id;
      shapeSelectionSource = 'list';

      updateShapeList();
      drawAllShapes();
      commit('New Object (pencil)');
    }

    //exit draw mode
    //exitFreehandMode();
    return;
  }

  const rect = canvas.getBoundingClientRect();
  const m = _mouseToCanvasSpace(e);
  
  const mouseMoved = mouseDownPos &&
    (m.x !== mouseDownPos.x || m.y !== mouseDownPos.y);

  if (mouseMoved) {
    commit('Shape Move');
  }

  // If it was effectively a click, apply selection logic now.
  if (mouseDownPos && !mouseMoved) {
    let clickedOnShape = false;

    if (mouseDownOnShapeId != null) {
      clickedOnShape = true;

      if (e.ctrlKey || e.metaKey) {
        // Toggle membership now (deferred from mousedown)
        const id = mouseDownOnShapeId;
        if (multiSelectedShapeIds.has(id)) {
          multiSelectedShapeIds.delete(id);
          if (selectedShapeId === id) {
            selectedShapeId = multiSelectedShapeIds.size > 0 ? [...multiSelectedShapeIds][0] : null;
          }
        } else {
          multiSelectedShapeIds.add(id);
          selectedShapeId = id;
        }
      } else {
        // Plain click: select only this shape (matches left panel)
        multiSelectedShapeIds.clear();
        multiSelectedShapeIds.add(mouseDownOnShapeId);
        selectedShapeId = mouseDownOnShapeId;
      }
    }

    if (!clickedOnShape) {
      //canvas.style.cursor = 'pointer';
      // Clear selection only if NOT holding Ctrl/Cmd (matches left panel expectations)
      if (!e.ctrlKey && !e.metaKey) {
        //shapeSelectionSource = 'canvas';
        multiSelectedShapeIds.clear();
        selectedShapeId = null;
      }
    }

    updateShapeList();
    drawAllShapes();
  }

  dragOffsets.clear();
  mouseDownPos = null;
  mouseDownOnShapeId = null;      // NEW
});


function exportProject(includeHistory = false){


  // Check if a background image exists and is fully loaded.
  if (backgroundImage && backgroundImage.complete && backgroundImage.naturalWidth > 0) {
    // To get the Base64 data, we draw the image to a temporary canvas.
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = backgroundImage.naturalWidth;
    tempCanvas.height = backgroundImage.naturalHeight;
    tempCtx.drawImage(backgroundImage, 0, 0);
    
    // Store the Base64 Data URL in the animation object before export.
    animation.canvas.backgroundImageSrc = tempCanvas.toDataURL();
  } else {
    // If there's no background, ensure we remove any old data.
    delete animation.canvas.backgroundImageSrc;
  }

  if (includeHistory) {
    animation.animationHistory = animationHistory;
  }

  const exportData = JSON.stringify(
    animation,
    (key, value) => (key === '_img' ? undefined : value),
    2
  );
  const blob = new Blob([exportData], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'animation.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

bgInputBtn.onclick = () => {
  bgInput.value = ''; // <-- Reset the file input so same file can be re-imported
  bgInput.click();
};

importBtn.onclick = () => {
  importFile.value = ''; // <-- Reset the file input so same file can be re-imported
  importFile.click();
};

importFile.onchange = e => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = evt => {
    loadKeyframesFromJSON(evt.target.result);
    importFile.value = ''; // <-- Reset the file input so same file can be re-imported
  };
  reader.readAsText(file);
};

shapes = [
  { id: shapeIdCounter++, type: 'circle',    name: 'head', x: 375, y:  147, w: 50, h: 50,  color: '#e74c3c', mode: 0, z: 5, locked: true },
  { id: shapeIdCounter++, type: 'rectangle', name: 'torso', x: 350, y: 207, w: 100, h: 100, color: '#2ecc71', mode: 0, z: 2, locked: true},
  { id: shapeIdCounter++, type: 'rectangle', name: 'left arm', x: 300, y: 207, w: 40,  h: 100, color: '#3498db', "angle": 18, mode: 0, z: 4, locked: true },
  { id: shapeIdCounter++, type: 'rectangle', name: 'right arm', x: 460, y: 207, w: 40,  h: 100, color: '#e67e22', "angle": -18, mode: 0, z: 3, locked: true },
  { id: shapeIdCounter++, type: 'rectangle', name: 'left leg', x: 350, y: 307, w: 40,  h: 100, color: '#9b59b6', mode: 0, z: 1, locked: true },
  { id: shapeIdCounter++, type: 'rectangle', name: 'right leg', x: 410, y: 307, w: 40,  h: 100, color: '#f1c40f', mode: 0, z: 0, locked: true }
];

shapes = normalizeZOrder();

// include default frames for the very first keyframe
animation.keyframes.push({
  id: makeShortUUID(),
  name: "Keyframe",
  shapes: cloneShapes(shapes),
  frames: 30
});
currentKeyframeIndex = 0;
updateShapeList();
drawAllShapes();
// pass null for playing param to match other calls
renderTimeline(currentKeyframeIndex, null);
commit('Init');

function loadKeyframesFromJSON(json) {
  try {
    const parsed = JSON.parse(json);

    if (!parsed || !Array.isArray(parsed.keyframes)) {
      throw new Error("Invalid animation format: missing keyframes.");
    }
    animation = parsed;

    // Fill in defaults if not present
    animation.title    ??= "Untitled Animation";
    animation.author   ??= "Unknown";
    animation.version  ??= 1;
    animation.canvas   ??= { width: 800, height: 600, background: "#f0f0f0" };
    bgColorInput.value = animation.canvas.background || '#f0f0f0';
    animation.settings ??= { frameRate: 30, loop: false };
    fpsInput.value = animation.settings.frameRate || 30;
    updatePresetHighlight();
    animation.keyframes.forEach(kf => { kf.frames ??= 30; });

    animation.keyframes.forEach(kf => {
      if (!kf.id) kf.id = makeShortUUID();
    });

    // Normalize z-order for every keyframe on import
    animation.keyframes.forEach(kf => {
      kf.shapes = normalizeZOrder(kf.shapes || []);
    });

    // Bump shapeIdCounter past imported IDs
    const allIds = animation.keyframes.flatMap(kf => kf.shapes.map(s => s.id));
    const maxId  = allIds.length ? Math.max(...allIds) : 0;
    shapeIdCounter = maxId + 1;

    // Recreate Image() objects for image shapes (ignore any _img from JSON)
    let imagesToLoad = 0;
    let imagesLoaded = 0;

    const onAllImagesReady = () => {
      // This runs only when every single image (bg and shapes) is loaded.
      currentKeyframeIndex = 0;
      // 🔹 Clone and normalize shapes for the live array
      shapes = cloneShapes(normalizeZOrder(animation.keyframes[0].shapes));
      updateShapeList();
      drawAllShapes();
      renderTimeline(currentKeyframeIndex, null);
    };

    // 1. Check for and load the background image.
    if (animation.canvas && animation.canvas.backgroundImageSrc) {
      imagesToLoad++;
      const bgImg = new Image();
      bgImg.onload = () => {
        backgroundImage = bgImg; // Set the global background image
        imagesLoaded++;
        if (imagesLoaded === imagesToLoad) onAllImagesReady();
      };
      bgImg.onerror = () => { // Handle potential load errors
        console.error("Failed to load background image from JSON.");
        imagesLoaded++;
        if (imagesLoaded === imagesToLoad) onAllImagesReady();
      };
      bgImg.src = animation.canvas.backgroundImageSrc;
    } else {
        backgroundImage = null; // Ensure bg is cleared if not in JSON
    }
    // 2. Loop through all keyframes to find and load shape images.
    animation.keyframes.forEach(kf => {
      kf.shapes.forEach(s => {
        if (s.type === 'image' && s.src) {
          imagesToLoad++;
          const img = new Image();
          img.onload = () => {
            s._img = img;
            imagesLoaded++;
            if (imagesLoaded === imagesToLoad) {
              // All images loaded → update shapes and UI
              currentKeyframeIndex = 0;
              shapes = cloneShapes(normalizeZOrder(animation.keyframes[0].shapes));
              updateShapeList();
              drawAllShapes();
              renderTimeline(currentKeyframeIndex, null);
            }
          };
          img.src = s.src;
          s._img = img; // placeholder until load finishes
        }
      });
    });

    // Restore animationHistory if present in imported JSON
    if (parsed.animationHistory && Array.isArray(parsed.animationHistory.history)) {
      const histCopy = JSON.parse(JSON.stringify(parsed.animationHistory));
      window.animationHistory.history = histCopy.history;
      window.animationHistory.index   = histCopy.index ?? histCopy.history.length - 1;
    }
    else{
      commit('Project File Loaded');
    }

    // If there are no images, we can proceed immediately
    if (imagesToLoad === 0) {
      currentKeyframeIndex = 0;
      shapes = cloneShapes(normalizeZOrder(animation.keyframes[0].shapes));
      updateShapeList();
      drawAllShapes();
      renderTimeline(currentKeyframeIndex, null);
    }

  } catch (e) {
    console.error("Failed to parse animation JSON:", e);
    alert("Import failed: invalid animation file.");
  }
}
  </script>

  <!-- Full‐screen modal for shortcuts map -->
  <div id="shortcut-modal" role="dialog" aria-modal="true" aria-labelledby="shortcut-title">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="shortcut-title">Keyboard Shortcuts</h2>
        <button id="close-modal" aria-label="Close">&times;</button>
      </div>
      <div class="modal-body">
        <ul>
        <b>Global:</b>
          <li><kbd>Spacebar</kbd> : Play/Stop (from selected Keyframe)</li>
          <li><kbd>Ctrl</kbd>+<kbd>Z</kbd> / <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd> : Undo/Redo</li>
          <li><kbd>F</kbd> : Toggle Fullscreen</li>
          <li><kbd>O</kbd> : Toogle Onion Skins</li>
          <li><kbd>P</kbd> : Toogle Motion Paths</li>
          <li><kbd>.</kbd> : Hide/Toggle Sidebar Menus</li>
        </ul>

        <ul>
        <b>With Shapes Selected:</b>
          <li><kbd>H</kbd> : Toogle Shape Highlighting</li>
          <li><kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> or <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd> : Move Shape/s</li>
          <li><kbd>Q</kbd> / <kbd>E</kbd> : Rotate object/s Left/Right</li>
          <li><kbd>Ctrl</kbd>+<kbd>D</kbd> : Duplicate Shape/s</li>
          <li><kbd>Ctrl</kbd>+<kbd>C</kbd> : Copy Shape/s</li>
          <li><kbd>Ctrl</kbd>+<kbd>V</kbd> : Paste Shape/s</li>
          <li><kbd>Tab</kbd> : Cycle Shapes or Keyframes</li>
          <li><kbd>Shift</kbd>+<kbd>Tab</kbd> : Reverse-cycle Shapes or Keyframes</li>
          <li><kbd>Ctrl</kbd>+<kbd>Left Mouse Click</kbd> : Select Multiple Shapes</li>
        </ul>

        <ul>
        <b>With Keyframes Selected:</b>
          <li><kbd>K</kbd> : Clone Current Keyframe</li>
          <li><kbd>Tab</kbd> : Cycle Keyframes</li>
        </ul>
      </div>
    </div>
  </div>

<script>
//KEYBOARD SHORTCUTS
let lastInteractionArea = null;

/* Guard: ignore global shortcuts while typing in editable controls */
function _isEditableTarget(e){
  const SELECTORS = [
    'input',
    'textarea',
    'select',
    '[contenteditable]',
    '[role="textbox"]',
    '[role="dialog"]',
    '[aria-modal="true"]',
    '[data-shortcuts="off"]'
  ].join(',');

  // 1) Normal DOM fast path
  const t = e.target;
  if (t && typeof t.closest === 'function' && t.closest(SELECTORS)) return true;

  // 2) Shadow DOM aware path check
  if (typeof e.composedPath === 'function') {
    const path = e.composedPath();
    for (let i = 0; i < path.length; i++) {
      const node = path[i];
      if (node && node.nodeType === 1 && typeof node.matches === 'function') {
        if (node.matches(SELECTORS)) return true;
      }
      if (node && node.host && typeof node.host.matches === 'function') {
        if (node.host.matches(SELECTORS)) return true;
      }
    }
  }

  return false;
}


// whenever the user clicks or focuses in one of these regions, record it:
canvas.addEventListener('mousedown',        () => { lastInteractionArea = 'canvas'; });
leftSidebar.addEventListener('mousedown',   () => { lastInteractionArea = 'leftSidebar'; });
rightSidebar.addEventListener('mousedown',  () => { lastInteractionArea = 'rightSidebar'; });

// Also track focus so keyboard navigation counts
leftSidebar.addEventListener('focusin',   () => { lastInteractionArea = 'leftSidebar'; });
rightSidebar.addEventListener('focusin',  () => { lastInteractionArea = 'rightSidebar'; });
canvas.addEventListener('focusin',        () => { lastInteractionArea = 'canvas'; });

const hint = document.getElementById('shortcut-hint');
const modal = document.getElementById('shortcut-modal');
const closeBtn = document.getElementById('close-modal');

// Function to toggle modal visibility
function toggleModal(show) {
  if (show) {
    modal.style.display = 'block';
  } else {
    modal.style.display = 'none';
  }
}

// Listen for keydown globally
document.addEventListener('keydown', (e) => {
  if (_isEditableTarget(e)) return;
  
  // If user presses '?' (Shift + '/')
  if (e.key === '?' && !e.ctrlKey && !e.metaKey && !e.altKey) {
    e.preventDefault();
    toggleModal(modal.style.display !== 'block');
  }
  if (e.code === 'Space') {
    e.preventDefault(); // stop browser from scrolling

    // Add fake active style
    newPlayBtn.classList.add('fake-active');
    setTimeout(() => {
      newPlayBtn.classList.remove('fake-active');
    }, 150); // 150ms matches your CSS transition

    newPlayBtn.click();
  }
  if (e.key === 'k') { cloneKeyframeBtn.click();}
  if (e.key === 'Escape') { toggleModal(false);}
  if (e.key === '.') {
    const next = leftSidebar.style.display !== 'none' ? 'none' : '';
    leftSidebar.style.display = next;
    rightSidebar.style.display = next;
  }
  if (e.key === 'f') {
    if (!document.fullscreenElement) {
    canvas.requestFullscreen().catch(err => {
      alert(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      document.exitFullscreen();
    }
  }
  if (e.key === 'h') {
    if (isPlaying){return;}
    shapeSelectionForce = (shapeSelectionForce !== true) ? true : false;
    drawAllShapes();
  }
});

// Close button click
closeBtn.addEventListener('click', () => toggleModal(false));

// Clicking outside the content closes modal
modal.addEventListener('click', (e) => {
  if (e.target === modal) {
    toggleModal(false);
  }
});

// ─── Tab / Shift+Tab to cycle shapes or keyframes ─────────────────────────
document.addEventListener('keydown', e => {
  if (_isEditableTarget(e)) return;
  if (e.key !== 'Tab') return;
  e.preventDefault();

  const backward = e.shiftKey;

  if (lastInteractionArea === 'canvas' || lastInteractionArea === 'leftSidebar') {
    if (shapes.length === 0) return;
    // cycle through shapes
    const ids = shapes.map(s => s.id);
    // pick a starting point
    let current = selectedShapeId != null
                ? selectedShapeId
                : ids[0];
    let idx = ids.indexOf(current);
    // advance or rewind
    if (idx === -1) idx = 0; // extra safety
    let nextIdx = (idx + (backward ? 1 : -1) + ids.length) % ids.length;
    let nextId  = ids[nextIdx];
    // select it
    multiSelectedShapeIds.clear();
    multiSelectedShapeIds.add(nextId);
    selectedShapeId = nextId;
    updateShapeList();
    drawAllShapes();

  } else if (lastInteractionArea === 'rightSidebar') {
    // cycle through keyframes
    const total = animation.keyframes.length;
    let idx = currentKeyframeIndex != null
            ? currentKeyframeIndex
            : 0;
    let nextIdx = (idx + (backward ? -1 : 1) + total) % total;
    currentKeyframeIndex = nextIdx;
    // load that keyframe
    shapes = cloneShapes(animation.keyframes[nextIdx].shapes);
    updateShapeList();
    drawAllShapes();
    renderTimeline(currentKeyframeIndex, null);
    document.querySelector('.kf-row.selected')?.scrollIntoView({ block: 'center' });
  }
});

// ─── Arrow/WASD nudges & Q/E rotation for selected shapes (with acceleration) ───
let _nudgeInt = null, _nudgeSpd = 1;
let keyMoveHappened = false;
let keyRotateHappened = false;

document.addEventListener('keydown', e => {
  if (_isEditableTarget(e)) return;

  // don’t nudge or rotate if Ctrl or Cmd is held
  if (e.ctrlKey || e.metaKey) return;
  const step = 1, rotStep = 1, max = 20, accel = 1;
  let dx = 0, dy = 0, dAngle = 0;
  const key = e.key.toLowerCase();

  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(key)) {
    keyMoveHappened = true;
  }
  if (['q','e'].includes(key)) {
    keyRotateHappened = true;
  }

  if (key === 'arrowup'    || key === 'w') dy = -step;
  else if (key === 'arrowdown'|| key === 's') dy =  step;
  else if (key === 'arrowleft'|| key === 'a') dx = -step;
  else if (key === 'arrowright'|| key === 'd') dx =  step;
  else if (key === 'q') dAngle = -rotStep;
  else if (key === 'e') dAngle =  rotStep;
  else return;

  e.preventDefault();
  if (_nudgeInt) return;
  _nudgeSpd = 1;

_nudgeInt = setInterval(() => {
    const moveDX = dx * _nudgeSpd;
    const moveDY = dy * _nudgeSpd;
    multiSelectedShapeIds.forEach(id => {
      const s = shapes.find(o => o.id === id);
      if (!s) return;

      // position / rotation
      s.x     += moveDX;
      s.y     += moveDY;
      s.angle = (s.angle || 0) + dAngle * _nudgeSpd;

      /* ⬇️ NEW: keep freehand path aligned with bbox while nudging */
      if (s.type === 'freehand' && Array.isArray(s.points)) {
        s.points.forEach(p => { p.x += moveDX; p.y += moveDY; });
      }

      if (currentKeyframeIndex != null) {
        const k = animation.keyframes[currentKeyframeIndex]
                          .shapes.find(o => o.id === id);
        if (k) {
          k.x     = s.x;
          k.y     = s.y;
          k.angle = s.angle;

          /* ⬇️ mirror the translated points in the keyframe copy */
          if (k.type === 'freehand' && Array.isArray(k.points)) {
            k.points.forEach(p => { p.x += moveDX; p.y += moveDY; });
          }
        }
      }
    });
    updateShapeList();
    drawAllShapes();
    _nudgeSpd = Math.min(max, _nudgeSpd + accel);
  }, 50);
});

document.addEventListener('keyup', e => {
  const key = e.key.toLowerCase();
  if (['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d','q','e'].includes(key)) {

    if (keyMoveHappened || keyRotateHappened){
      keyMoveHappened = false;
      keyRotateHappened = false;
      e.preventDefault();
      clearInterval(_nudgeInt);
      _nudgeInt = null;

      if (!isDragging()){
        commit('move/rotate nudge');
      }
    }
  }
});

// ─── Ctrl+D to clone selected shapes ─────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (_isEditableTarget(e)) return;

  // Detect Ctrl+D (or Cmd+D on Mac)
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
    e.preventDefault();

    const newIds = [];
    // For each selected shape, clone it
    multiSelectedShapeIds.forEach(id => {
      const original = shapes.find(s => s.id === id);
      if (!original) return;

      // Create a copy and assign a fresh ID
      const copy = cloneShape(original);
      copy.id = shapeIdCounter++;
      shapes.push(copy);

      // Also clone into all keyframes from the current one onward
      if (currentKeyframeIndex != null) {
        for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
          const kfCopy = cloneShape(copy);
          animation.keyframes[i].shapes.push(kfCopy);
        }
      }

      newIds.push(copy.id);
    });

    // Update the selection to the newly cloned shapes
    multiSelectedShapeIds.clear();
    newIds.forEach(id => multiSelectedShapeIds.add(id));

    updateShapeList();
    drawAllShapes();
  }
});

/// ─── Clipboard for shapes copy/paste with ID preservation when crossing keyframes ─────────────────
let shapeClipboard = { shapes: [], sourceKeyframeIndex: null };

document.addEventListener('keydown', e => {
  if (_isEditableTarget(e)) return;

  const key = e.key.toLowerCase();

  // Ctrl+C: Copy selected shapes
  if ((e.ctrlKey || e.metaKey) && key === 'c') {
    e.preventDefault();
    if (!multiSelectedShapeIds.size) return;
    // Deep-clone each selected shape (preserving its original id)
    shapeClipboard.shapes = [...multiSelectedShapeIds]
      .map(id => {
        const s = shapes.find(o => o.id === id);
        return s ? cloneShape(s) : null;
      })
      .filter(Boolean);
    shapeClipboard.sourceKeyframeIndex = currentKeyframeIndex;

    navigator.clipboard.writeText("__SHAPE_CLIPBOARD__").catch(() => {
    // Fallback: ignore if permissions denied
    });
  }

  
});

// ─── Delete / Backspace to remove selected shapes from CURRENT keyframe only ──
document.addEventListener('keydown', e => {
  if (_isEditableTarget(e)) return;  // keep typing safe
  if (e.key !== 'Delete' && e.key !== 'Backspace') return;
  if (lastInteractionArea !== 'canvas' && lastInteractionArea !== 'leftSidebar') return;
  if (!multiSelectedShapeIds.size) return;
  if (currentKeyframeIndex == null) return; // only act when a keyframe is selected

  e.preventDefault();

  const idsToDelete = new Set(multiSelectedShapeIds);

  // 1) Remove from the live shapes array (what you see on canvas)
  shapes = normalizeZOrder(shapes.filter(s => !idsToDelete.has(s.id)));

  // 2) Remove ONLY from the current keyframe
  animation.keyframes[currentKeyframeIndex].shapes =
    normalizeZOrder(animation.keyframes[currentKeyframeIndex].shapes.filter(s => !idsToDelete.has(s.id)));

  // 3) Clean up selection
  if (idsToDelete.has(selectedShapeId)) selectedShapeId = null;
  multiSelectedShapeIds.clear();

  updateShapeList();
  drawAllShapes();
  commit('Shape Delete');
});


</script>
<script>
    const fpsInput = document.getElementById("fpsInput");
    const fpsButtons = document.getElementById("fpsButtons");

    // Helper: update which preset button is active
    function updatePresetHighlight() {
      const currentFps = parseInt(animation.settings.frameRate, 10);
      fpsButtons.querySelectorAll("button").forEach(btn => {
        if (parseInt(btn.dataset.fps, 10) === currentFps) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }
    // init number input
    fpsInput.value = animation.settings.frameRate || 30;
    updatePresetHighlight();

    fpsInput.addEventListener("change", () => {
      let fps = parseInt(fpsInput.value, 10);
      if (isNaN(fps) || fps < 1) fps = 1;
      if (fps > 240) fps = 240;
      animation.settings.frameRate = fps;
      fpsInput.value = fps; // clamp
      updatePresetHighlight();
    });

    fpsButtons.addEventListener("click", (e) => {
      if (e.target.matches("button[data-fps]")) {
        const fps = parseInt(e.target.dataset.fps, 10);
        animation.settings.frameRate = fps;
        fpsInput.value = fps;
        updatePresetHighlight();
      }
    });
</script>
<script src="https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.js"></script>
<script>
/**exportGifBtn.onclick = async () => {
  if (animation.keyframes.length < 2) {
    alert("Need at least 2 keyframes to export a GIF.");
    return;
  }

  const fps = Math.max(1, Math.floor((animation.settings && animation.settings.frameRate) || 30));
  const gif = new GIF({
    workers: 2,
    quality: 10,
    width: canvas.width,
    height: canvas.height,
    workerScript: URL.createObjectURL(new Blob([`
      importScripts('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
    `], { type: 'application/javascript' }))
  });

  // show the progress bar
  const progressEl = document.getElementById('gifProgress');
  progressEl.value = 0;
  progressEl.style.display = 'block';

  let segments = [];
  for (let i = 0; i < animation.keyframes.length - 1; i++) {
    segments.push([i, i + 1]);
  }

  for (const [fromIdx, toIdx] of segments) {
    const a = animation.keyframes[fromIdx];
    const b = animation.keyframes[toIdx];
    const steps = a.frames || 30;
    const easer = EASERS[a.easing] || (x => x);

    for (let t = 0; t < steps; t++) {
      const rawT = t / steps;
      const easedT = easer(rawT);
      let interp;
      if (a.easing === 'none') {
        interp = (t >= steps - 1) ? b.shapes : a.shapes;
      } else if (a.easing === 'spiral') {
        interp = interpolateShapesSpiral(a, b, easedT);
      } else if (a.easing === 'wavy') {
        interp = interpolateShapesWavy(a, b, easedT);
      } else {
        interp = interpolateShapes(a, b, easedT);
      }

      drawAllShapes(interp);

      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = canvas.width;
      frameCanvas.height = canvas.height;
      frameCanvas.getContext('2d').drawImage(canvas, 0, 0);

      gif.addFrame(frameCanvas, { delay: 1000 / fps });
    }
  }

  gif.on('progress', (p) => {
    progressEl.value = p;
  });

  gif.on('finished', (blob) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'animation.gif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // hide the progress bar after download
    progressEl.style.display = 'none';
  });

  gif.render();
};
**/

exportGifBtn.onclick = async () => {
  if (animation.keyframes.length < 2) {
    alert("Need at least 2 keyframes to export a GIF.");
    return;
  }

  const exportW = animation.canvas.width;
  const exportH = animation.canvas.height;

  const fps = Math.max(1, Math.floor((animation.settings && animation.settings.frameRate) || 30));
  const gif = new GIF({
    workers: 2,
    quality: 10,
    width: exportW,
    height: exportH,
    workerScript: URL.createObjectURL(new Blob([`
      importScripts('https://cdn.jsdelivr.net/npm/gif.js.optimized/dist/gif.worker.js');
    `], { type: 'application/javascript' }))
  });

  // show the progress bar
  const progressEl = document.getElementById('gifProgress');
  progressEl.value = 0;
  progressEl.style.display = 'block';

  let segments = [];
  for (let i = 0; i < animation.keyframes.length - 1; i++) {
    segments.push([i, i + 1]);
  }

  for (const [fromIdx, toIdx] of segments) {
    const a = animation.keyframes[fromIdx];
    const b = animation.keyframes[toIdx];
    const steps = a.frames || 30;
    const easer = EASERS[a.easing] || (x => x);

    for (let t = 0; t < steps; t++) {
      const rawT = t / steps;
      const easedT = easer(rawT);
      let interp;
      if (a.easing === 'none') {
        interp = (t >= steps - 1) ? b.shapes : a.shapes;
      } else if (a.easing === 'spiral') {
        interp = interpolateShapesSpiral(a, b, easedT);
      } else if (a.easing === 'wavy') {
        interp = interpolateShapesWavy(a, b, easedT);
      } else {
        interp = interpolateShapes(a, b, easedT);
      }

      // ⬇️ render into an offscreen canvas at logical resolution
      const frameCanvas = document.createElement('canvas');
      frameCanvas.width = exportW;
      frameCanvas.height = exportH;
      const fctx = frameCanvas.getContext('2d');
      fctx.setTransform(1, 0, 0, 1, 0, 0);

      // draw background + shapes just like drawAllShapes, but targeting fctx
      fctx.fillStyle = animation.canvas.background || '#f0f0f0';
      fctx.fillRect(0, 0, exportW, exportH);
      if (backgroundImage) {
        fctx.drawImage(backgroundImage, 0, 0, exportW, exportH);
      }
      const ordered = [...interp].sort((a, b) => (a.z ?? 0) - (b.z ?? 0));
      ordered.forEach(s => drawShape(fctx, s)); // reuse drawShape with fctx bound

      gif.addFrame(frameCanvas, { delay: 1000 / fps });
    }
  }

  gif.on('progress', (p) => {
    progressEl.value = p;
  });

  gif.on('finished', (blob) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'animation.gif';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // hide the progress bar after download
    progressEl.style.display = 'none';
  });

  gif.render();
};


// Single paste handler: handles both images and shape clipboard
document.addEventListener("paste", event => {
  const items = event.clipboardData?.items;
  if (!items) return;

  // 1) Check if clipboard has an image
  for (const item of items) {
    if (item.type.startsWith("image/")) {
      const file = item.getAsFile();
      if (!file) continue;

      const reader = new FileReader();
      reader.onload = e => {
        const dataUrl = e.target.result;
        const img = new Image();
        img.onload = () => {
          const maxW = 200, maxH = 200;
          let w = img.naturalWidth, h = img.naturalHeight;
          const scale = Math.min(1, maxW / w, maxH / h);
          w = Math.max(1, Math.round(w * scale));
          h = Math.max(1, Math.round(h * scale));

          const s = {
            id: shapeIdCounter++,
            type: "image",
            x: 100 + Math.random() * 400,
            y: 100 + Math.random() * 250,
            w, h,
            angle: 0,
            z: shapes.length,
            locked: true,
            mode: 0,
            src: dataUrl,
            _img: img
          };

          shapes.push(s);
          if (currentKeyframeIndex != null) {
            for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
              animation.keyframes[i].shapes.push(cloneShape(s));
            }
          }

          updateShapeList();
          drawAllShapes();
        };
        img.src = dataUrl;
      };
      reader.readAsDataURL(file);

      event.preventDefault();
      return; // stop here if image handled
    }
  }

  // 2) Otherwise, handle shape paste (Ctrl+V shapes)
  if (!shapeClipboard.shapes.length) return;
  if (currentKeyframeIndex == null) return;

  event.preventDefault();

  const sameFrame = shapeClipboard.sourceKeyframeIndex === currentKeyframeIndex;
  const newIds = [];

  const frameIds = new Set(animation.keyframes[currentKeyframeIndex].shapes.map(s => s.id));
  const liveIds  = new Set(shapes.map(s => s.id));
  const idExists = id => frameIds.has(id) || liveIds.has(id);

  shapeClipboard.shapes.forEach(orig => {
    const copy = cloneShape(orig);

    if (sameFrame || idExists(copy.id)) {
      let newId = shapeIdCounter++;
      while (idExists(newId)) newId = shapeIdCounter++;
      copy.id = newId;
    }

    shapes.push(copy);
    newIds.push(copy.id);
    liveIds.add(copy.id);

    const kfCopy = cloneShape(copy);
    animation.keyframes[currentKeyframeIndex].shapes.push(kfCopy);
    frameIds.add(copy.id);
  });

  multiSelectedShapeIds.clear();
  newIds.forEach(id => multiSelectedShapeIds.add(id));
  selectedShapeId = newIds.length === 1 ? newIds[0] : null;

  updateShapeList();
  drawAllShapes();
});

// Enable drag-and-drop image import
canvas.addEventListener("dragover", e => {
  e.preventDefault(); // allow drop
});

canvas.addEventListener("drop", e => {
  e.preventDefault();

  const files = e.dataTransfer.files;
  if (!files.length) return;

  for (const file of files) {
    if (!file.type.startsWith("image/")) continue;

    const reader = new FileReader();
    reader.onload = ev => {
      const dataUrl = ev.target.result;
      const img = new Image();
      img.onload = () => {
        const maxW = 200, maxH = 200;
        let w = img.naturalWidth, h = img.naturalHeight;
        const scale = Math.min(1, maxW / w, maxH / h);
        w = Math.max(1, Math.round(w * scale));
        h = Math.max(1, Math.round(h * scale));

        const s = {
          id: shapeIdCounter++,
          type: "image",
          x: e.offsetX,          // drop at cursor position
          y: e.offsetY,
          w, h,
          angle: 0,
          z: shapes.length,
          locked: true,
          mode: 0,
          src: dataUrl,
          _img: img
        };

        shapes.push(s);
        if (currentKeyframeIndex != null) {
          for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
            animation.keyframes[i].shapes.push(cloneShape(s));
          }
        }

        updateShapeList();
        drawAllShapes();
      };
      img.src = dataUrl;
    };
    reader.readAsDataURL(file);
  }
});

</script>
<!-- emoji-picker-element (vanilla, no framework) -->
<script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>

<!-- The popup (hidden by default) -->
<emoji-picker id="emojiPicker" style="position:absolute; display:none; z-index:3000;"></emoji-picker>

<script>
  (function () {
    const btn   = document.getElementById('emojiButton');
    const input = document.getElementById('textContent');
    const picker= document.getElementById('emojiPicker');

    function insertAtCursor(el, text){
      const [s, e] = [el.selectionStart ?? el.value.length, el.selectionEnd ?? el.value.length];
      el.value = el.value.slice(0, s) + text + el.value.slice(e);
      const pos = s + text.length;
      el.setSelectionRange(pos, pos);
      el.focus();
    }

    function togglePicker(){
      const r = btn.getBoundingClientRect();
      picker.style.left = (r.left + window.scrollX) + 'px';
      picker.style.top  = (r.bottom + window.scrollY + 6) + 'px';
      picker.style.display = (picker.style.display === 'none' ? 'block' : 'none');
    }

    btn.addEventListener('click', (e) => { e.stopPropagation(); input.focus(); togglePicker(); });

    picker.addEventListener('emoji-click', (e) => {
      insertAtCursor(input, e.detail.unicode);
      picker.style.display = 'none';
    });

    document.addEventListener('click', (e) => {
      if (picker.style.display !== 'none' && !picker.contains(e.target) && e.target !== btn) {
        picker.style.display = 'none';
      }
    });
  })();
</script>
<script>
  // Delete helper used by the split button (no prompts; scope provided by the menu).
  // scope: "1" = current keyframe only
  //        "2" = this and forward keyframes
  //        "3" = all keyframes
  function deleteShapeWithScope(id, scope) {
    // 1) remove from live shapes shown on canvas
    shapes = normalizeZOrder(shapes.filter(o => o.id !== id));

    // 2) apply to keyframes based on scope
    if (currentKeyframeIndex != null) {
      if (scope === "2") {
        for (let i = currentKeyframeIndex; i < animation.keyframes.length; i++) {
          animation.keyframes[i].shapes =
            normalizeZOrder(animation.keyframes[i].shapes.filter(o => o.id !== id));
        }
      } else if (scope === "3") {
        for (let i = 0; i < animation.keyframes.length; i++) {
          animation.keyframes[i].shapes =
            normalizeZOrder(animation.keyframes[i].shapes.filter(o => o.id !== id));
        }
      } else {
        // "1" (default): current keyframe only
        animation.keyframes[currentKeyframeIndex].shapes =
          normalizeZOrder(animation.keyframes[currentKeyframeIndex].shapes.filter(o => o.id !== id));
      }
    }

    // 3) selection cleanup
    if (multiSelectedShapeIds.has(id)) multiSelectedShapeIds.delete(id);
    if (selectedShapeId === id) selectedShapeId = null;

    // 4) refresh UI
    updateShapeList();
    drawAllShapes();
    commit('Shape Delete');
  }

// create ASCII-style history bar
(function(){
  const bar = document.createElement('div');
  bar.id = 'historyBar';
  bar.style.cssText = `
    position:fixed;
    bottom:8px;
    left:50%;
    transform:translateX(-50%);
    font-family:monospace;
    font-size:14px;
    letter-spacing:2px;
    color:#aaa;
    background:#eef5ff;
    padding:3px 8px;
    border-radius:6px;
    user-select:none;
    z-index:9999;
    opacity:0;
    transition:opacity .35s ease;
    pointer-events:none;
  `;
  document.body.appendChild(bar);

  // local state
  let active = 0;
  let total = 0;
  let fadeTimer = null;
  const FADE_DELAY = 3000; // ms before fade out

  function showBar(){
    bar.style.opacity = '1';
    clearTimeout(fadeTimer);
    fadeTimer = setTimeout(()=> bar.style.opacity = '0', FADE_DELAY);
  }

  function render(){
    total = (window.animationHistory?.history?.length || 0);
    if (total === 0){
      bar.textContent = '';
      return;
    }
    active = Math.max(0, Math.min(active, total - 1));
    bar.innerHTML = Array.from({length: total}, (_,i)=>
      `<span style="color:${i===active?'#ff4040':'#999'}">${i===active?'●':'–'}</span>`
    ).join('');
  }

  // initial draw
  render();

  // keyboard listeners (Ctrl/Cmd + Z)
  window.addEventListener('keydown', e=>{
    const typing = /^(INPUT|TEXTAREA)$/.test(e.target.tagName) || e.target.isContentEditable;
    if (typing) return;
    const mod = e.ctrlKey || e.metaKey;
    if (!mod) return;
    if (e.key.toLowerCase()==='z'){
      e.preventDefault();
      const len = window.animationHistory?.history?.length || 0;
      if (len !== total){ total = len; }
      if (e.shiftKey) active = Math.min(active + 1, len - 1); // redo
      else active = Math.max(active - 1, 0); // undo
      render();
      showBar(); // 👈 only show on undo/redo
    }
  });

  // when commit() adds new snapshots, update silently (no show)
  const origCommit = window.commit;
  if (typeof origCommit === 'function'){
    window.commit = (...args)=>{
      const r = origCommit(...args);
      const len = window.animationHistory?.history?.length || 0;
      total = len;
      active = Math.max(0, len - 1);
      render();
      return r;
    };
  }

  // expose manual refresh if needed
  window.renderHistoryBar = render;
})();
</script>

<!-- ────────────────────────────────────────────────
      DARK MODE
──────────────────────────────────────────────── -->
<style>
  #darkModeToggle {
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 99999;
    background: #222;
    color: #fff;
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    cursor: pointer;
    font-size: 18px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    transition: background 0.25s, transform 0.1s;
  }
  #darkModeToggle:hover { background: #444; }
  #darkModeToggle:active { transform: scale(0.9); }

  body.dark-mode {
    background: #1e1e1e;
    color: #ddd;
  }

  /* Sidebars, Tabs, Groups, Lists */
  body.dark-mode #leftSidebar,
  body.dark-mode #rightSidebar,
  body.dark-mode #sidebar,
  body.dark-mode .tab-content,
  body.dark-mode .pro-header,
  body.dark-mode .group-control,
  body.dark-mode .shape-row,
  body.dark-mode .kf-row,
  body.dark-mode #canvasList,
  body.dark-mode #objectList,
  body.dark-mode #filesList,
  body.dark-mode #timeline,
  body.dark-mode #shapeList,
  body.dark-mode #shapeList.shape-list--pro,
  body.dark-mode #objectList.object-list--pro,
  body.dark-mode #canvasList.object-list--pro,
  body.dark-mode #filesList.object-list--pro,
  body.dark-mode #timeline.kf-list--pro {
    background: #2a2a2a !important;
    color: #eee !important;
    border-color: #444 !important;
  }

  /* Tabs */
  body.dark-mode .tab {
    background: #333 !important;
    color: #eee !important;
    border-color: #444 !important;
  }
  body.dark-mode .tab.active {
    background: #444 !important;
    color: #fff !important;
  }

  /* Buttons */
  body.dark-mode button {
    background: #333 !important;
    color: #eee !important;
    border-color: #555 !important;
  }

  /* Inputs and selects */
  body.dark-mode input,
  body.dark-mode select {
    background: #444 !important;
    color: #fff !important;
    border-color: #555 !important;
  }

  /* Canvas and control buttons */
  body.dark-mode canvas {
    background: #333 !important;
    border-color: #444 !important;
  }

  body.dark-mode #bigPlay button,
  body.dark-mode #loopAnimation,
  body.dark-mode #bounceAnimation,
  body.dark-mode #fullscreenBtn,
  body.dark-mode #onionToggleBtn {
    background: #333 !important;
    color: #eee !important;
  }

  /* Scrollbars for dark mode */
  body.dark-mode ::-webkit-scrollbar-thumb {
    background: #555 !important;
  }
  body.dark-mode ::-webkit-scrollbar-thumb:hover {
    background: #666 !important;
  }
    body.dark-mode #shortcut-hint {
    background: #2c2c2c !important;
    color: #f0f0f0 !important;
    box-shadow: 0 0 6px rgba(0,0,0,0.4) !important;
    border: 1px solid #444 !important;
  }

  body.dark-mode #shortcut-hint kbd {
    background: #555 !important;
    color: #fff !important;
    border: 1px solid #666 !important;
  }

  /* Shortcut modal overlay */
  body.dark-mode #shortcut-modal {
    background: rgba(0, 0, 0, 0.75) !important;
  }

  /* Shortcut modal content box */
  body.dark-mode #shortcut-modal .modal-content {
    background: #2b2b2b !important;
    color: #eee !important;
    border: 1px solid #444 !important;
  }

  body.dark-mode #shortcut-modal .modal-header {
    background: #333 !important;
    border-bottom: 1px solid #444 !important;
    color: #fff !important;
  }

  body.dark-mode #shortcut-modal .modal-body {
    background: #2b2b2b !important;
  }

  body.dark-mode #shortcut-modal .modal-body li {
    color: #ddd !important;
  }

  body.dark-mode #shortcut-modal .modal-body kbd {
    background: #444 !important;
    color: #fff !important;
    border: 1px solid #666 !important;
    box-shadow: inset 0 -1px 0 #111 !important;
  }

  body.dark-mode #close-modal {
    color: #fff !important;
  }

  body.dark-mode #close-modal:hover {
    background: #444 !important;
  }

  body.dark-mode img#logoImg {
    filter: contrast(0);
  }
</style>

<script>
(function(){
  // Create button dynamically and append into existing controls cluster
  const controls = document.getElementById('controls');
  if (controls) {
    const btn = document.createElement('button');
    btn.id = 'darkModeBtn';
    btn.textContent = '🌙 Dark';
    btn.title = 'Toggle Dark Mode';
    controls.appendChild(btn);

    const savedMode = localStorage.getItem('animatey-dark-mode');
    if (savedMode === 'true') {
      document.body.classList.add('dark-mode');
      btn.textContent = '☀️ Light';
    }

    btn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      const isDark = document.body.classList.contains('dark-mode');
      btn.textContent = isDark ? '☀️ Light' : '🌙 Dark';
      localStorage.setItem('animatey-dark-mode', isDark);
    });
  }
})();
</script>
<!-- ────────────────────────────────────────────────
     END DARK MODE
──────────────────────────────────────────────── -->
<!-- ────────────────────────────────────────────────
     MOTION PATH EDITING
──────────────────────────────────────────────── -->
<!-- ────────────────────────────────────────────────
     🧭 MOTION PATH EDITING (Pro Feature)
     Drop this entire block just before </body>
     It is 100% self-contained and non-destructive.
──────────────────────────────────────────────── -->
<script>
(function(){

  // Global flags
  window.motionPathsEnabled = false;
  // Remember the last non-null selected keyframe index so paths persist during playback
  window._mp_lastSelectedKFIndex = (typeof currentKeyframeIndex === 'number') ? currentKeyframeIndex : null;

  const btn = document.getElementById('motionPathToggleBtn');
  if (btn) {
    btn.onmousedown = (e)=>e.preventDefault();
    btn.onclick = ()=>{
      motionPathsEnabled = !motionPathsEnabled;
      btn.classList.toggle('playing', motionPathsEnabled);

      // When turning ON, snapshot the currently selected keyframe (for playback persistence)
      if (motionPathsEnabled) {
        if (typeof currentKeyframeIndex === 'number') {
          window._mp_lastSelectedKFIndex = currentKeyframeIndex;
        }
      }
      drawAllShapes();
    };
  } else {
    console.warn('Motion path toggle button not found (#motionPathToggleBtn or #moationPathToggleBtn).');
  }

  // Preserve original drawAllShapes if not wrapped yet
  if (!window._drawAllShapes_original_forMotionPaths) {
    window._drawAllShapes_original_forMotionPaths = drawAllShapes;
  }

  // Replace drawAllShapes with extended version
  drawAllShapes = function(state = shapes) {
    // Draw normal frame first (your loop calls this every frame during playback)
    _drawAllShapes_original_forMotionPaths(state);

    if (!motionPathsEnabled || !animation || !animation.keyframes?.length) return;

    // Keep track of latest selected keyframe whenever it's defined
    if (typeof currentKeyframeIndex === 'number') {
      window._mp_lastSelectedKFIndex = currentKeyframeIndex;
    }

    // Use the current selected keyframe if available; otherwise the last selected one (during playback)
    const effectiveKFIndex =
      (typeof currentKeyframeIndex === 'number') ? currentKeyframeIndex : window._mp_lastSelectedKFIndex;

    if (effectiveKFIndex == null) return;

    const currentKF = animation.keyframes[effectiveKFIndex];
    if (!currentKF || !currentKF.shapes?.length) return;

    try {
      ctx.save();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'rgba(80,160,255,0.5)';
      ctx.fillStyle   = 'rgba(80,160,255,0.9)';

      // Filter: only shapes that exist in the (effective) current keyframe
      const visibleIds = currentKF.shapes.map(s => s.id);

      // Build/draw motion tracks only for these shapes
      for (const id of visibleIds) {
        const track = [];
        for (let idx = 0; idx < animation.keyframes.length; idx++) {
          const kf = animation.keyframes[idx];
          const s  = kf.shapes.find(sh => sh.id === id);
          if (s) {
            track.push({
              x: s.x + s.w / 2,
              y: s.y + s.h / 2,
              idx
            });
          }
        }

        if (track.length < 2) continue; // no motion across frames

        // draw path
        ctx.beginPath();
        ctx.moveTo(track[0].x, track[0].y);
        for (let i = 1; i < track.length; i++) ctx.lineTo(track[i].x, track[i].y);
        ctx.stroke();

        // draw anchors
        const isNum = (v)=>typeof v === 'number';
        const highlightIdx = isNum(currentKeyframeIndex) ? currentKeyframeIndex : effectiveKFIndex;

        track.forEach(pt => {
          const isCurrent = (pt.idx === highlightIdx);
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, isCurrent ? 5 : 3, 0, Math.PI * 2);
          ctx.fillStyle = isCurrent ? 'rgba(50,130,255,0.9)' : 'rgba(80,160,255,0.6)';
          ctx.fill();
          if (!isCurrent) {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 3.8, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(80,160,255,0.4)';
            ctx.stroke();
          }
        });
      }

      ctx.restore();
    } catch(err) {
      console.warn('Motion path draw error:', err);
    }
  };

})();

function framesToTime(frames, fps) {
  fps = fps || (animation.settings?.frameRate || 30);
  const kf = animation.keyframes || [];

  if (typeof frames === 'number') return frames / fps;
  if (kf.length === 0) return 0;

  // Sum all keyframe.frames
  let totalFrames = 0;
  // only count frames from keyframes that serve as 'from' in a→b pairs
  for (let i = 0; i < kf.length - 1; i++) {
    totalFrames += kf[i].frames || 0;
  }



  return totalFrames / fps;
}

const playTimer = document.getElementById('playTimer');

function updatePlayTimer(currentFrame = 0) {
  const fps = animation.settings?.frameRate || 30;
  const totalSeconds = framesToTime(); // your helper
  const currentSeconds = currentFrame / fps;

  playTimer.textContent = `${currentSeconds.toFixed(2)} / ${totalSeconds.toFixed(2)}s`;
}

// initial label
updatePlayTimer();

function setupPlayTimer() {
  const btn   = document.getElementById('newPlayBtn');
  const timer = document.getElementById('playTimer');
  if (!btn || !timer) return;

  let hideTimeout;

  timer.style.transition = 'opacity 0.3s ease';
  timer.style.opacity    = '0';
  timer.style.visibility = 'hidden';

  btn.addEventListener('mouseenter', () => {
    // cancel any pending hide
    clearTimeout(hideTimeout);
    timer.style.visibility = 'visible';
    timer.style.opacity    = '0.8';
  });

  btn.addEventListener('mouseleave', () => {
    clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => {
      timer.style.opacity = '0';
      // hide after fade-out completes, but only if still not hovering
      hideTimeout = setTimeout(() => {
        if (!btn.matches(':hover')) timer.style.visibility = 'hidden';
      }, 300);
    }, 0);
  });
}
setupPlayTimer();

</script>

<!-- ────────────────────────────────────────────────
     END MOTION PATH EDITING
──────────────────────────────────────────────── -->
</body>
</html>
